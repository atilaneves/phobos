
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2015 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Templates Revisited - D Programming Language</title>

<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" href="css/style.css" />
<link rel="stylesheet" href="css/print.css" media="print" />
<link rel="stylesheet" href="css/cssmenu.css">
<link rel="shortcut icon" href="favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0" />

</head>
<body id='Templates Revisited' class='doc'>
<script type="text/javascript">document.body.className += ' have-javascript'</script>
<div id="top">	<div id="header">		<img src="images/hamburger.svg" id="mobile-hamburger">
		<a class="logo" href="."><img id="logo" width="125" height="95" alt="D Logo" src="images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href="." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    
    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000" /></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option  value="dlang.org/phobos">Library Reference</option>
                    <option  value="forum.dlang.org">Discussion Forums</option>
                    
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='index.html'><span>D 2.068.1</span></a></li>
    <li><a href='download.html'><span><b>Download</b></span></a></li>
    <li><a href='getstarted.html'><span>Getting Started</span></a></li>
    <li><a href='changelog/2.068.1.html'><span>Change Log</span></a></li>
    <li class='has-sub'><a href='#'><span>D Reference</span></a>
      <ul><li><a href='        intro.html'>Introduction</a></li><li><a href='        lex.html'>Lexical</a></li><li><a href='        grammar.html'>Grammar</a></li><li><a href='        module.html'>Modules</a></li><li><a href='        declaration.html'>Declarations</a></li><li><a href='        type.html'>Types</a></li><li><a href='        property.html'>Properties</a></li><li><a href='        attribute.html'>Attributes</a></li><li><a href='        pragma.html'>Pragmas</a></li><li><a href='        expression.html'>Expressions</a></li><li><a href='        statement.html'>Statements</a></li><li><a href='        arrays.html'>Arrays</a></li><li><a href='        hash-map.html'>Associative Arrays</a></li><li><a href='        struct.html'>Structs and Unions</a></li><li><a href='        class.html'>Classes</a></li><li><a href='        interface.html'>Interfaces</a></li><li><a href='        enum.html'>Enums</a></li><li><a href='        const3.html'>Const and Immutable</a></li><li><a href='        function.html'>Functions</a></li><li><a href='        operatoroverloading.html'>Operator Overloading</a></li><li><a href='        template.html'>Templates</a></li><li><a href='        template-mixin.html'>Template Mixins</a></li><li><a href='        contracts.html'>Contract Programming</a></li><li><a href='        version.html'>Conditional Compilation</a></li><li><a href='        traits.html'>Traits</a></li><li><a href='        errors.html'>Error Handling</a></li><li><a href='        unittest.html'>Unit Tests</a></li><li><a href='        garbage.html'>Garbage Collection</a></li><li><a href='        float.html'>Floating Point</a></li><li><a href='        iasm.html'>D x86 Inline Assembler</a></li><li><a href='        ddoc.html'>Embedded Documentation</a></li><li><a href='        interfaceToC.html'>Interfacing to C</a></li><li><a href='        cpp_interface.html'>Interfacing to C++</a></li><li><a href='        portability.html'>Portability Guide</a></li><li><a href='        entity.html'>Named Character Entities</a></li><li><a href='        memory-safe-d.html'>Memory Safety</a></li><li><a href='        abi.html'>Application Binary Interface</a></li><li><a href='        simd.html'>Vector Extensions
      </a></li></ul>
    <li><a href='phobos/index.html'><span>Standard library</span></a></li>
    <li><a href='http://code.dlang.org'><span>DUB &ndash; The D package registry</span></a></li>
    <li class='has-sub'><a href='#'><span>Community</span></a>
      <ul><li><a href='        bugstats.php'>Bug Tracker</a></li><li><a href='        http://forum.dlang.org'>Forums</a></li><li><a href='        irc://irc.freenode.net/d'>IRC</a></li><li><a href='        http://github.com/D-Programming-Language'>D on GitHub</a></li><li><a href='        http://wiki.dlang.org'>Wiki</a></li><li><a href='        http://wiki.dlang.org/Review_Queue'>Review Queue</a></li><li><a href='        http://twitter.com/search?q=%23dlang'>Twitter</a></li><li><a href='        http://digitalmars.com/d/dlinks.html'>More Links
      </a></li></ul>
    <li class='has-sub'><a href='#'><span>Compilers &amp; Tools</span></a>
      <ul><li><a href='        dmd-windows.html'>dmd &ndash; reference compiler</a></li><li><a href='        http://gdcproject.org'>gdc &ndash; gcc-based compiler</a></li><li><a href='        http://wiki.dlang.org/LDC'>ldc &ndash; LLVM-based compiler</a></li><li><a href='        http://code.dlang.org/download'>DUB &ndash; D package manager</a></li><li><a href='        https://github.com/Hackerpilot/dfix'>dfix &ndash; D source code upgrade</a></li><li><a href='        https://github.com/Hackerpilot/dfmt'>dfmt &ndash; D source code formatting tool</a></li><li><a href='        rdmd.html'>rdmd &ndash; build tool</a></li><li><a href='        htod.html'>htod &ndash; .h to .d
      </a></li></ul>
    <li class='has-sub'><a href='#'><span>Books &amp; Articles</span></a>
      <ul><li><a href='        http://ddili.org/ders/d.en/index.html'>Online Book (free)</a></li><li><a href='        http://wiki.dlang.org/Books'>More Books</a></li><li><a href='        howtos.html'>How-tos</a></li><li><a href='        faq.html'>FAQ</a></li><li><a href='        const-faq.html'>const(FAQ)</a></li><li><a href='        comparison.html'>Feature Overview</a></li><li><a href='        d-floating-point.html'>Floating Point</a></li><li><a href='        wc.html'>Example: wc</a></li><li><a href='        warnings.html'>Warnings</a></li><li><a href='        rationale.html'>Rationale</a></li><li><a href='        builtin.html'>Builtin Rationale</a></li><li><a href='        ctod.html'>C to D</a></li><li><a href='        cpptod.html'>C++ to D</a></li><li><a href='        pretod.html'>C Preprocessor vs D</a></li><li><a href='        code_coverage.html'>Code coverage analysis</a></li><li><a href='        exception-safe.html'>Exception Safety</a></li><li><a href='        hijack.html'>Hijacking</a></li><li><a href='        intro-to-datetime.html'>Introduction to std.datetime</a></li><li><a href='        lazy-evaluation.html'>Lazy Evaluation</a></li><li><a href='        migrate-to-shared.html'>Migrating to Shared</a></li><li><a href='        mixin.html'>Mixins</a></li><li><a href='        regular-expression.html'>Regular Expressions</a></li><li><a href='        safed.html'>SafeD</a></li><li><a href='        templates-revisited.html'>Templates Revisited</a></li><li><a href='        tuple.html'>Tuples</a></li><li><a href='        ctarguments.html'>Compile-time Argument Lists</a></li><li><a href='        variadic-function-templates.html'>Variadic Templates</a></li><li><a href='        d-array-article.html'>D Slices
      </a></li></ul>
    <li class='has-sub'><a href='#'><span>Resources</span></a>
      <ul><li><a href='        library/index.html'>NEW Library Reference Preview</a></li><li><a href='        http://rainers.github.io/visuald/visuald/StartPage.html'>Visual D</a></li><li><a href='        http://wiki.dlang.org/Editors'>Editors</a></li><li><a href='        http://wiki.dlang.org/IDEs'>IDEs</a></li><li><a href='        dstyle.html'>The D Style</a></li><li><a href='        glossary.html'>Glossary</a></li><li><a href='        acknowledgements.html'>Acknowledgments</a></li><li><a href='        sitemap.html'>Sitemap
      </a></li></ul>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://issues.dlang.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2Fdlang.org/&bug_severity=enhancement&component=dlang.org&op_sys=All&priority=P3&product=D&rep_platform=All&short_desc=%5BTemplates Revisited%5D&version=D2" class="button">Report a bug</a>
		<span >			If you spot a problem with this page, click here to create a Bugzilla issue.
		</span>
	</span>
	<span class="tip">		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/templates-revisited.dd" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
</div>
    <h1>Templates Revisited</h1>
    
    <!--Generated by Ddoc from templates-revisited.dd-->



<center>
<i>by Walter Bright, <a href="http://www.digitalmars.com/d">http://www.digitalmars.com/d</a></i>

<br>
<br>

<blockquote><p>What I am going to tell you about is what we teach our programming students in
the third or fourth year of graduate school... It is my task to convince you not
to turn away because you don't understand it. You see my programming students
don't understand it... That is because I don't understand it. Nobody does.
 <cite>Richard Deeman</cite></p></blockquote>
</center>

<h2>Abstract</h2>

<p>Templates in C++ have evolved from little more than token substitution into a
programming language in itself. Many useful aspects of C++ templates have been
discovered rather than designed. A side effect of this is that C++ templates are
often criticized for having an awkward syntax, many arcane rules, and being very
difficult to implement properly. What might templates look like if one takes a
step back, looks at what templates can do and what uses they are put to, and
redesign them? Can templates be powerful, aesthetically pleasing, easy to
explain and straightforward to implement?
This article takes a look at an alternative design of templates in the D
Programming Language [1].
</p>

<h2>Similarities</h2>

<ul><li>compile time semantics</li>
<li>function templates</li>
<li>class templates</li>
<li>type parameters</li>
<li>value parameters</li>
<li>template parameters</li>
<li>partial and explicit specialization</li>
<li>type deduction</li>
<li>implicit function template instantiation</li>
<li><acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</li>
</ul>


<h2>Argument Syntax</h2>

<p>The first thing that comes to mind is the use of &lt; &gt; to enclose parameter
lists and argument lists. &lt; &gt; has a couple serious problem, however.
They are ambiguous with operators &lt;, &gt;, and &gt;&gt;. This means that expressions
like:
</p>

<pre class="ccode notranslate">a&lt;b,c&gt;d;
</pre>

and:

<pre class="ccode notranslate">a&lt;b&lt;c&gt;&gt;d;
</pre>

<p>are syntactically ambiguous, both to the compiler and the programmer.
If you run across <span class="d_inlinecode donthyphenate notranslate">a&lt;b,c&gt;d;</span> in unfamiliar code, you've got to slog through
an arbitrarily large amount of declarations and <span class="d_inlinecode donthyphenate notranslate">.h</span> files to figure out
if it is a template or not.
How much effort has been expended by programmers, compiler writers, and
language standard writers to deal with this?
</p>

<p>There's got to be a better way. D solves it by noticing that ! is not used
as a binary operator, so replacing:
</p>

<pre class="ccode notranslate">a&lt;b,c&gt;
</pre>

<p>with:
</p>

<pre class="d_code notranslate">a!(b,c)
</pre>

<p>is syntactically unambiguous. This makes it easy to parse, easy to generate
reasonable error messages for, and makes it easy for someone inspecting the
code to determine that yes, <span class="d_inlinecode donthyphenate notranslate">a</span> must be a template.
</p>


<h2>Template Definition Syntax</h2>

<p>C++ can define two broad types of templates: class templates, and function
templates. Each template is written independently, even if they are
closely related:
</p>

<pre class="ccode notranslate">template&lt;class T, class U&gt; class Bar { ... };

template&lt;class T, class U&gt; T foo(T t, U u) { ... }

template&lt;class T, class U&gt; static T abc;
</pre>

<p>POD (Plain Old Data, as in C style) structs
bring together related data declarations, classes bring together
related data and function declarations, but there's nothing to logically group
together templates that are to be instantiated together.
In D, we can write:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> Foo(T, U)
{
    <span class="d_keyword">class</span> Bar { ... }

    T foo(T t, U u) { ... }

    T abc;

    <span class="d_keyword">typedef</span> T* Footype; <span class="d_comment">// any declarations can be templated
</span>}
</pre>

<p>The <span class="d_inlinecode donthyphenate notranslate">Foo</span> forms a name space for the templates, which are accessed by,
for example:
</p>

<pre class="d_code notranslate">Foo!(<span class="d_keyword">int</span>,<span class="d_keyword">char</span>).Bar b;
Foo!(<span class="d_keyword">int</span>,<span class="d_keyword">char</span>).foo(1,2);
Foo!(<span class="d_keyword">int</span>,<span class="d_keyword">char</span>).abc = 3;
</pre>

<p>Of course, this can get a little tedious, so one can use an alias
for a particular instantiation:
</p>

<pre class="d_code notranslate"><span class="d_keyword">alias</span> f = Foo!(<span class="d_keyword">int</span>,<span class="d_keyword">char</span>);
f.Bar b;
f.foo(1,2);
f.abc = 3;
</pre>

<p>For class templates, there's an even simpler syntax. A class is defined
like:
</p>

<pre class="d_code notranslate"><span class="d_keyword">class</span> Abc
{
    <span class="d_keyword">int</span> t;
    ...
}
</pre>

<p>This can be turned into a template by just adding a parameter list:
</p>

<pre class="d_code notranslate"><span class="d_keyword">class</span> Abc(T)
{
    T t;
    ...
}
</pre>


<h2>Template Declaration, Definition, and Export</h2>

<p>C++ templates can be in the form of a template declaration, a template
definition, and an exported template.
Because D has a true module system, rather than textual #include files,
there are only template definitions in D. The need for template declarations
and export is irrelevant. For example, given a template definition in
module <span class="d_inlinecode donthyphenate notranslate">A</span>:
</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> A;

<span class="d_keyword">template</span> Foo(T)
{
    T bar;
}
</pre>

<p>it can be accessed from module <span class="d_inlinecode donthyphenate notranslate">B</span> like:
</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> B;

<span class="d_keyword">import</span> A;

<span class="d_keyword">void</span> test()
{
    A.Foo!(<span class="d_keyword">int</span>).bar = 3;
}
</pre>

<p>As usual, an alias can be used to simplify access:
</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> B;

<span class="d_keyword">import</span> A;
<span class="d_keyword">alias</span> bar = A.Foo!(<span class="d_keyword">int</span>).bar;

<span class="d_keyword">void</span> test()
{
    bar = 3;
}
</pre>


<h2>Template Parameters</h2>

<p>C++ template parameters can be:</p>

<ul><li>types</li>
<li>integral values</li>
<li>static/global addresses</li>
<li>template names</li>
</ul>

<p>D template parameters can be:</p>

<ul><li>types</li>
<li>integral values</li>
<li>floating point values</li>
<li>string literals</li>
<li>templates</li>
<li>or any symbol</li>
</ul>

<p>Each can have default values,
and type parameters can have (a limited form of) constraints:
</p>

<pre class="d_code notranslate"><span class="d_keyword">class</span> B { ... }
<span class="d_keyword">interface</span> I { ... }

<span class="d_keyword">class</span> Foo(
    R,            <span class="d_comment">// R can be any type
</span>    P:P*,         <span class="d_comment">// P must be a pointer type
</span>    T:<span class="d_keyword">int</span>,        <span class="d_comment">// T must be int type
</span>    S:T*,         <span class="d_comment">// S must be pointer to T
</span>    C:B,          <span class="d_comment">// C must be of class B or derived
</span>                  <span class="d_comment">// from B
</span>    U:I,          <span class="d_comment">// U must be interface I, or any interface
</span>                  <span class="d_comment">// or class which has interface I in its
</span>                  <span class="d_comment">// inheritance tree
</span>    string str = <span class="d_string">"hello"</span>,
                  <span class="d_comment">// string literal,
</span>                  <span class="d_comment">// default is "hello"
</span>    <span class="d_keyword">alias</span> A = B   <span class="d_comment">// A is any symbol
</span>                  <span class="d_comment">// (including template symbols),
</span>                  <span class="d_comment">// defaulting to B
</span>    )
{
    ...
}
</pre>

<h2>Specialization</h2>

<p>Partial and explicit specialization work as they do in C++, except that
there is no notion of a &lsquo;primary&rsquo; template. All the templates with the
same name are examined upon template instantiation, and the one with the
best fit of arguments to parameters is instantiated.
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> Foo(T) ...
<span class="d_keyword">template</span> Foo(T:T*) ...
<span class="d_keyword">template</span> Foo(T, U:T) ...
<span class="d_keyword">template</span> Foo(T, U) ...
<span class="d_keyword">template</span> Foo(T, U:<span class="d_keyword">int</span>) ...

Foo!(<span class="d_keyword">long</span>)       <span class="d_comment">// picks Foo(T)
</span>Foo!(<span class="d_keyword">long</span>[])     <span class="d_comment">// picks Foo(T), T is long[]
</span>Foo!(<span class="d_keyword">int</span>*)       <span class="d_comment">// picks Foo(T*), T is int
</span>Foo!(<span class="d_keyword">long</span>,<span class="d_keyword">long</span>)  <span class="d_comment">// picks Foo(T, U:T)
</span>Foo!(<span class="d_keyword">long</span>,<span class="d_keyword">short</span>) <span class="d_comment">// picks Foo(T, U)
</span>Foo!(<span class="d_keyword">long</span>,<span class="d_keyword">int</span>)   <span class="d_comment">// picks Foo(T, U:int)
</span>Foo!(<span class="d_keyword">int</span>,<span class="d_keyword">int</span>)    <span class="d_comment">// ambiguous - Foo(T, U:T)
</span>                 <span class="d_comment">// or Foo(T, U:int)
</span></pre>

<h2>Two Level Name Lookup</h2>

<p>C++ has some unusual rules for name lookup inside templates, such
as not looking inside base classes, not allowing scoped redeclaration
of template parameter names, and not considering overloads that
happen after the point of definition (this example is
derived from one in the C++98 Standard):
</p>

<pre class="ccode notranslate">int g(double d) { return 1; }

typedef double A;

template&lt;class T&gt; struct B
{
    typedef int A;
};

template&lt;class T&gt; struct X : B&lt;T&gt;
{
    A a;              // a has type double
    int T;            // error, T redeclared
    int foo()
    {
        char T;       // error, T redeclared
        return g(1);  // always returns 1
    }
};

int g(int i) { return 2; }  // this definition not seen by X
</pre>

<p>Scoped lookup rules in D match the rules for the rest of the language:
</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span> g(<span class="d_keyword">double</span> d) { <span class="d_keyword">return</span> 1; }

<span class="d_keyword">alias</span> A = <span class="d_keyword">double</span>;

<span class="d_keyword">class</span> B(T)
{
    <span class="d_keyword">alias</span> A = <span class="d_keyword">int</span>;
}

<span class="d_keyword">class</span> X(T) : B!(T)
{
    A a;             <span class="d_comment">// a has type int
</span>    <span class="d_keyword">int</span> T;           <span class="d_comment">// ok, T redeclared as int
</span>    <span class="d_keyword">int</span> foo()
    {
        <span class="d_keyword">char</span> T;      <span class="d_comment">// ok, T redeclared as char
</span>        <span class="d_keyword">return</span> g(1); <span class="d_comment">// always returns 2
</span>    }
};

<span class="d_keyword">int</span> g(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> 2; }  <span class="d_comment">// functions can be forward referenced
</span></pre>



<h2>Template Recursion</h2>

<p>Template recursion combined with specialization means that C++ templates
actually form a programming language, although certainly
an odd one. Consider a set of templates that computes a factorial at
run time. Like "hello world" programs, factorial is the canonical example
of template metaprogramming:
</p>

<pre class="ccode notranslate">template&lt;int n&gt; class factorial
{
    public:
        enum
        {
            result = n * factorial&lt;n - 1&gt;::result
        };
};

template&lt;&gt; class factorial&lt;1&gt;
{
    public:
        enum { result = 1 };
};

void test()
{
    // prints 24
    printf("%d\n", factorial&lt;4&gt;::result);
}
</pre>

<p>Recursion works as well in D, though with significantly less typing:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">const</span> factorial = n * factorial!(n-1);
}

<span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n : 1)
{
    <span class="d_keyword">const</span> factorial = 1;
}

<span class="d_keyword">void</span> test()
{
    writeln(factorial!(4));  <span class="d_comment">// prints 24
</span>}
</pre>

<p>Through using the <span class="d_inlinecode donthyphenate notranslate">static if</span> construct it can be done in just one
template:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (n == 1)
        <span class="d_keyword">const</span> factorial = 1;
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> factorial = n * factorial!(n-1);
}
</pre>

<p>reducing 13 lines of code to an arguably much cleaner 7 lines.
<span class="d_inlinecode donthyphenate notranslate">static if</span>'s are the equivalent of C++'s <span class="d_inlinecode donthyphenate notranslate">#if</span>.
But <span class="d_inlinecode donthyphenate notranslate">#if</span> cannot access template
arguments, so all template conditional compilation must be handled with
partial and explicitly specialized templates.
<span class="d_inlinecode donthyphenate notranslate">static if</span> dramatically simplifies
such constructions.
</p>

<p>D can make this even simpler. Value generating templates such
as the factorial one are possible, but it's easier to just write
a function that can be computed at compile time:</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">if</span> (n == 1)
        <span class="d_keyword">return</span> 1;
    <span class="d_keyword">else</span>
        <span class="d_keyword">return</span> n * factorial(n - 1);
}

<span class="d_keyword">static</span> <span class="d_keyword">int</span> x = factorial(5);  <span class="d_comment">// x is statically initialized to 120
</span></pre>

<h2><acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</h2>

<p>This determines if the template's argument type is a function,
from "<i>C++ Templates: The Complete Guide</i>",
Vandevoorde &amp; Josuttis pg. 353:
</p>

<pre class="ccode notranslate">template&lt;U&gt; class IsFunctionT
{
    private:
        typedef char One;
        typedef struct { char a[2]; } Two;
        template static One test(...);
        template static Two test(U (*)[1]);
    public:
        enum
        {
            Yes = sizeof(IsFunctionT::test(0)) == 1
        };
};

void test()
{
    typedef int (fp)(int);

    assert(IsFunctionT&lt;fp&gt;::Yes == 1);
}
</pre>

<p>Template <span class="d_inlinecode donthyphenate notranslate">IsFunctionT</span> relies on two side effects to achieve its result.
First, it relies on arrays of functions being an invalid C++ type.
Thus, if <span class="d_inlinecode donthyphenate notranslate">U</span> is a function type, the second <span class="d_inlinecode donthyphenate notranslate">test</span> will not be selected
since to do so would cause an error (<a href="http://dlang.org/glossary.html#sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)">sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</a>).
The first <span class="d_inlinecode donthyphenate notranslate">test</span> will be selected.
If <span class="d_inlinecode donthyphenate notranslate">U</span> is not a function type, the second <span class="d_inlinecode donthyphenate notranslate">test</span> is a better fit than ... .
Next, it is determined which <span class="d_inlinecode donthyphenate notranslate">test</span> was selected by examining the size
of the return value, i.e. <span class="d_inlinecode donthyphenate notranslate">sizeof(One)</span> or <span class="d_inlinecode donthyphenate notranslate">sizeof(Two)</span>.
Unfortunately, template metaprogramming in C++ often seems to be relying
on side effects rather than being able to expressly code what is desired.
</p>

<p>In D this can be written:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> IsFunctionT(T)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(T[]))
        <span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 0;
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>(IsFunctionT!(fp) == 1);
}
</pre>

<p>The <span class="d_inlinecode donthyphenate notranslate">is(T[])</span> is the equivalent of <a href="http://dlang.org/glossary.html#sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)">sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</a>.
It tries to build an array of <span class="d_inlinecode donthyphenate notranslate">T</span>,
and if <span class="d_inlinecode donthyphenate notranslate">T</span> is a function type, it is an array of functions. Since this is
an invalid type, the <span class="d_inlinecode donthyphenate notranslate">T[]</span> fails and <span class="d_inlinecode donthyphenate notranslate">is(T[])</span> returns false.
</p>

<p>Although <a href="http://dlang.org/glossary.html#sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)">sfinae, <acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</a> can be used, the <a href="expression.html#IsExpression">is expressions</a> can test a type directly,
so it isn't even necessary to use a template to ask questions about a type:
</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(fp == <span class="d_keyword">function</span>));
}
</pre>

<h2>Template Metaprogramming With Floats</h2>

<p>Let's move on to things that are impractical with templates in C++.
For example, this template returns the square root of
real number <span class="d_inlinecode donthyphenate notranslate">x</span> using the Babylonian method:
</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">template</span> sqrt(<span class="d_keyword">real</span> x, <span class="d_keyword">real</span> root = x/2, <span class="d_keyword">int</span> ntries = 0)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (ntries == 5)
        <span class="d_comment">// precision doubles with each iteration,
</span>        <span class="d_comment">// 5 should be enough
</span>        <span class="d_keyword">const</span> sqrt = root;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (root * root - x == 0)
        <span class="d_keyword">const</span> sqrt = root;  <span class="d_comment">// exact match
</span>    <span class="d_keyword">else</span>
        <span class="d_comment">// iterate again
</span>        <span class="d_keyword">const</span> sqrt = sqrt!(x, (root+x/root)/2, ntries+1);
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">real</span> x = sqrt!(2);
    writefln(<span class="d_string">"%.20g"</span>, x); <span class="d_comment">// 1.4142135623730950487
</span>}
</pre>

<p>Literal square roots are often needed for speed reasons in other runtime
floating point computations, such as computing the gamma function.
These template floating point algorithms need not be efficient as they are
computed at compile time, they only need to be accurate.
</p>

<p>Much more complex templates can be built, for example, Don Clugston
has written a template to compute &pi; at compile time. [2]
</p>

<p>Again, we can just do this with a function that can be executed
at compile time:</p>

<pre class="d_code notranslate"><span class="d_keyword">real</span> sqrt(<span class="d_keyword">real</span> x)
{
    <span class="d_keyword">real</span> root = x / 2;
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> ntries = 0; ntries &lt; 5; ntries++)
    {
        <span class="d_keyword">if</span> (root * root - x == 0)
            <span class="d_keyword">break</span>;
        root = (root + x / root) / 2;
    }
    <span class="d_keyword">return</span> root;
}
<span class="d_keyword">static</span> y = sqrt(10);   <span class="d_comment">// y is statically initialized to 3.16228
</span></pre>

<h2>Template Metaprogramming With Strings</h2>

<p>Even more interesting things can be done with strings. This example
converts an integer to a string at compile time:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> decimalDigit(<span class="d_keyword">int</span> n)    <span class="d_comment">// [3]
</span>{
    <span class="d_keyword">const</span> string decimalDigit = <span class="d_string">"0123456789"</span>[n..n+1];
}

<span class="d_keyword">template</span> itoa(<span class="d_keyword">long</span> n)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (n &lt; 0)
        <span class="d_keyword">const</span> string itoa = <span class="d_string">"-"</span> ~ itoa!(-n);
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (n &lt; 10)
        <span class="d_keyword">const</span> string itoa = decimalDigit!(n);
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> string itoa = itoa!(n/10L) ~ decimalDigit!(n%10L);
}

string foo()
{
    <span class="d_keyword">return</span> itoa!(264);   <span class="d_comment">// returns "264"
</span>}
</pre>

<p>This template will compute the hash of a string literal:
</p>

<pre class="d_code notranslate"><span class="d_keyword">template</span> hash(<span class="d_keyword">char</span> [] s, <span class="d_keyword">uint</span> sofar=0)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (s.length == 0)
        <span class="d_keyword">const</span> hash = sofar;
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> hash = hash!(s[1 .. $], sofar * 11 + s[0]);
}

<span class="d_keyword">uint</span> foo()
{
    <span class="d_keyword">return</span> hash!(<span class="d_string">"hello world"</span>);
}
</pre>

<h2>Regular Expression Compiler</h2>

<p>How do D templates fare with something much more significant, like
a regular expression compiler? Eric Niebler has written one for C++
that relies on expression templates. [4]
The problem with using expression templates is that one is restricted
to using only C++ operator syntax and precedence.
Hence, regular expressions using expression templates don't look like
regular expressions, they look like C++ expressions.
Eric Anderton has written one for D that relies on the ability of
templates to parse strings. [5]
This means that, within the strings, one can use the expected regular
expression grammar and operators.
</p>

<p>The regex compiler templates parse the regex string argument,
pulling off tokens
one by one from the front, and instantiating custom template functions
for each token predicate,
eventually combining them all into one function that directly implements
the regular expression.
It even gives reasonable error messages for syntax errors in
the regular expression.
</p>

<p>Calling that function with an argument of a string to match returns
an array of matching strings:
</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> regex;

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">auto</span> exp = &amp;regexMatch!(<span class="d_string">r"[a-z]*\s*\w*"</span>);
    writefln(<span class="d_string">"matches: %s"</span>, exp(<span class="d_string">"hello    world"</span>));
}
</pre>

<p>What follows is a cut-down version of Eric Anderton's regex compiler.
It is just enough to compile the regular expression above,
serving to illustrate how it is done.
</p>

<pre class="d_code notranslate"><span class="d_keyword">module</span> regex;

<span class="d_keyword">const</span> <span class="d_keyword">int</span> testFail = -1;

<span class="d_comment">/**
 * Compile pattern[] and expand to a custom generated
 * function that will take a string str[] and apply the
 * regular expression to it, returning an array of matches.
 */</span>

<span class="d_keyword">template</span> regexMatch(string pattern)
{
    string[] regexMatch(string str)
    {
        string[] results;
        <span class="d_keyword">int</span> n = regexCompile!(pattern).fn(str);
        <span class="d_keyword">if</span> (n != testFail &amp;&amp; n &gt; 0)
            results ~= str[0..n];
        <span class="d_keyword">return</span> results;
    }
}

<span class="d_comment">/******************************
 * The testXxxx() functions are custom generated by templates
 * to match each predicate of the regular expression.
 *
 * Params:
 *	string str	the input string to match against
 *
 * Returns:
 *	testFail	failed to have a match
 *	n &gt;= 0		matched n characters
 */</span>

<span class="d_comment">/// Always match
</span><span class="d_keyword">template</span> testEmpty()
{
    <span class="d_keyword">int</span> testEmpty(string str) { <span class="d_keyword">return</span> 0; }
}

<span class="d_comment">/// Match if testFirst(str) and testSecond(str) match
</span><span class="d_keyword">template</span> testUnion(<span class="d_keyword">alias</span> testFirst, <span class="d_keyword">alias</span> testSecond)
{
    <span class="d_keyword">int</span> testUnion(string str)
    {
        <span class="d_keyword">int</span> n1 = testFirst(str);
        <span class="d_keyword">if</span> (n1 != testFail)
        {
            <span class="d_keyword">int</span> n2 = testSecond(str[n1 .. $]);
            <span class="d_keyword">if</span> (n2 != testFail)
                <span class="d_keyword">return</span> n1 + n2;
        }
        <span class="d_keyword">return</span> testFail;
    }
}

<span class="d_comment">/// Match if first part of str[] matches text[]
</span><span class="d_keyword">template</span> testText(string text)
{
    <span class="d_keyword">int</span> testText(string str)
    {
        <span class="d_keyword">if</span> (str.length &amp;&amp;
            text.length &lt;= str.length &amp;&amp;
            str[0..text.length] == text)
        {
            <span class="d_keyword">return</span> text.length;
        }
        <span class="d_keyword">return</span> testFail;
    }
}

<span class="d_comment">/// Match if testPredicate(str) matches 0 or more times
</span><span class="d_keyword">template</span> testZeroOrMore(<span class="d_keyword">alias</span> testPredicate)
{
    <span class="d_keyword">int</span> testZeroOrMore(string str)
    {
        <span class="d_keyword">if</span> (str.length == 0)
            <span class="d_keyword">return</span> 0;
        <span class="d_keyword">int</span> n = testPredicate(str);
        <span class="d_keyword">if</span> (n != testFail)
        {
            <span class="d_keyword">int</span> n2 = testZeroOrMore!(testPredicate)(str[n .. $]);
            <span class="d_keyword">if</span> (n2 != testFail)
                <span class="d_keyword">return</span> n + n2;
            <span class="d_keyword">return</span> n;
        }
        <span class="d_keyword">return</span> 0;
    }
}

<span class="d_comment">/// Match if term1[0] &lt;= str[0] &lt;= term2[0]
</span><span class="d_keyword">template</span> testRange(string term1, string term2)
{
    <span class="d_keyword">int</span> testRange(string str)
    {
        <span class="d_keyword">if</span> (str.length &amp;&amp; str[0] &gt;= term1[0]
                       &amp;&amp; str[0] &lt;= term2[0])
            <span class="d_keyword">return</span> 1;
        <span class="d_keyword">return</span> testFail;
    }
}

<span class="d_comment">/// Match if ch[0]==str[0]
</span><span class="d_keyword">template</span> testChar(string ch)
{
    <span class="d_keyword">int</span> testChar(string str)
    {
        <span class="d_keyword">if</span> (str.length &amp;&amp; str[0] == ch[0])
            <span class="d_keyword">return</span> 1;
        <span class="d_keyword">return</span> testFail;
    }
}

<span class="d_comment">/// Match if str[0] is a word character
</span><span class="d_keyword">template</span> testWordChar()
{
    <span class="d_keyword">int</span> testWordChar(string str)
    {
        <span class="d_keyword">if</span> (str.length &amp;&amp;
            (
             (str[0] &gt;= 'a' &amp;&amp; str[0] &lt;= 'z') ||
             (str[0] &gt;= 'A' &amp;&amp; str[0] &lt;= 'Z') ||
             (str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') ||
             str[0] == '_'
            )
           )
        {
            <span class="d_keyword">return</span> 1;
        }
        <span class="d_keyword">return</span> testFail;
    }
}

<span class="d_comment">/*****************************************************/</span>

<span class="d_comment">/**
 * Returns the front of pattern[] up until
 * the end or a special character.
 */</span>

<span class="d_keyword">template</span> parseTextToken(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (isSpecial!(pattern))
            <span class="d_keyword">const</span> string parseTextToken = <span class="d_string">""</span>;
        <span class="d_keyword">else</span>
            <span class="d_keyword">const</span> string parseTextToken =
                pattern[0..1] ~ parseTextToken!(pattern[1..$]);
    }
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> string parseTextToken=<span class="d_string">""</span>;
}

<span class="d_comment">/**
 * Parses pattern[] up to and including terminator.
 * Returns:
 *	token[]	 	everything up to terminator.
 *	consumed	number of characters in pattern[] parsed
 */</span>
<span class="d_keyword">template</span> parseUntil(string pattern,<span class="d_keyword">char</span> terminator,<span class="d_keyword">bool</span> fuzzy=<span class="d_keyword">false</span>)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == '\\')
        {
            <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 1)
            {
                <span class="d_keyword">const</span> string nextSlice = pattern[2 .. $];
                <span class="d_keyword">alias</span> next = parseUntil!(nextSlice,terminator,fuzzy);
                <span class="d_keyword">const</span> string token = pattern[0 .. 2] ~ next.token;
                <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = next.consumed+2;
            }
            <span class="d_keyword">else</span>
            {
                <span class="d_keyword">pragma</span>(msg,<span class="d_string">"Error: expected character to follow \\"</span>);
                <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
            }
        }
        <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == terminator)
        {
            <span class="d_keyword">const</span> string token=<span class="d_string">""</span>;
            <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 1;
        }
        <span class="d_keyword">else</span>
        {
            <span class="d_keyword">const</span> string nextSlice = pattern[1 .. $];
            <span class="d_keyword">alias</span> next = parseUntil!(nextSlice,terminator,fuzzy);
            <span class="d_keyword">const</span> string token = pattern[0..1] ~ next.token;
            <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = next.consumed+1;
        }
    }
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (fuzzy)
    {
        <span class="d_keyword">const</span> string token = <span class="d_string">""</span>;
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 0;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">pragma</span>(msg, <span class="d_string">"Error: expected "</span> ~
                    terminator ~
                    <span class="d_string">" to terminate group expression"</span>);
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
    }
}

<span class="d_comment">/**
 * Parse contents of character class.
 * Params:
 *   pattern[] = rest of pattern to compile
 * Output:
 *   fn       = generated function
 *   consumed = number of characters in pattern[] parsed
 */</span>

<span class="d_keyword">template</span> regexCompileCharClass2(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 1)
        {
            <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[1] == '-')
            {
                <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 2)
                {
                    <span class="d_keyword">alias</span> termFn = testRange!(pattern[0..1], pattern[2..3]);
                    <span class="d_keyword">const</span> <span class="d_keyword">uint</span> thisConsumed = 3;
                    <span class="d_keyword">const</span> string remaining = pattern[3 .. $];
                }
                <span class="d_keyword">else</span> <span class="d_comment">// length is 2
</span>                {
                    <span class="d_keyword">pragma</span>(msg,
                      <span class="d_string">"Error: expected char following '-' in char class"</span>);
                    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
                }
            }
            <span class="d_keyword">else</span> <span class="d_comment">// not '-'
</span>            {
                <span class="d_keyword">alias</span> termFn = testChar!(pattern[0..1]);
                <span class="d_keyword">const</span> <span class="d_keyword">uint</span> thisConsumed = 1;
                <span class="d_keyword">const</span> string remaining = pattern[1 .. $];
            }
        }
        <span class="d_keyword">else</span>
        {
            <span class="d_keyword">alias</span> termFn = testChar!(pattern[0..1]);
            <span class="d_keyword">const</span> <span class="d_keyword">uint</span> thisConsumed = 1;
            <span class="d_keyword">const</span> string remaining = pattern[1 .. $];
        }
        <span class="d_keyword">alias</span> recurse = regexCompileCharClassRecurse!(termFn,remaining);
        <span class="d_keyword">alias</span> fn = recurse.fn;
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = recurse.consumed + thisConsumed;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">alias</span> fn = testEmpty!();
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 0;
    }
}

<span class="d_comment">/**
 * Used to recursively parse character class.
 * Params:
 *  termFn = generated function up to this point
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function including termFn and
 *       parsed character class
 *  consumed = number of characters in pattern[] parsed
 */</span>

<span class="d_keyword">template</span> regexCompileCharClassRecurse(<span class="d_keyword">alias</span> termFn,string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0 &amp;&amp; pattern[0] != ']')
    {
        <span class="d_keyword">alias</span> next = regexCompileCharClass2!(pattern);
        <span class="d_keyword">alias</span> fn = testOr!(termFn,next.fn,pattern);
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = next.consumed;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">alias</span> fn = termFn;
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 0;
    }
}

<span class="d_comment">/**
 * At start of character class. Compile it.
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */</span>

<span class="d_keyword">template</span> regexCompileCharClass(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == ']')
        {
            <span class="d_keyword">alias</span> fn = testEmpty!();
            <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 0;
        }
        <span class="d_keyword">else</span>
        {
            <span class="d_keyword">alias</span> charClass = regexCompileCharClass2!(pattern);
            <span class="d_keyword">alias</span> fn = charClass.fn;
            <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = charClass.consumed;
        }
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">pragma</span>(msg,<span class="d_string">"Error: expected closing ']' for character class"</span>);
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
    }
}

<span class="d_comment">/**
 * Look for and parse '*' postfix.
 * Params:
 *  test = function compiling regex up to this point
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */</span>

<span class="d_keyword">template</span> regexCompilePredicate(<span class="d_keyword">alias</span> test, string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0 &amp;&amp; pattern[0] == '*')
    {
        <span class="d_keyword">alias</span> fn = testZeroOrMore!(test);
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 1;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">alias</span> fn = test;
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 0;
    }
}

<span class="d_comment">/**
 * Parse escape sequence.
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 *  consumed = number of characters in pattern[] parsed
 */</span>

<span class="d_keyword">template</span> regexCompileEscape(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == 's')
        {
            <span class="d_comment">// whitespace char
</span>            <span class="d_keyword">alias</span> fn = testRange!(<span class="d_string">"\x00"</span>,<span class="d_string">"\x20"</span>);
        }
        <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == 'w')
        {
            <span class="d_comment">// word char
</span>            <span class="d_keyword">alias</span> fn = testWordChar!();
        }
        <span class="d_keyword">else</span>
        {
            <span class="d_keyword">alias</span> fn = testChar!(pattern[0 .. 1]);
        }
        <span class="d_keyword">const</span> <span class="d_keyword">uint</span> consumed = 1;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">pragma</span>(msg,<span class="d_string">"Error: expected char following '\\'"</span>);
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">false</span>);
    }
}

<span class="d_comment">/**
 * Parse and compile regex represented by pattern[].
 * Params:
 *  pattern[] = rest of pattern to compile
 * Output:
 *  fn = generated function
 */</span>

<span class="d_keyword">template</span> regexCompile(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == '[')
        {
            <span class="d_keyword">const</span> string charClassToken =
                parseUntil!(pattern[1 .. $],']').token;
            <span class="d_keyword">alias</span> charClass = regexCompileCharClass!(charClassToken);
            <span class="d_keyword">const</span> string token = pattern[0 .. charClass.consumed+2];
            <span class="d_keyword">const</span> string next = pattern[charClass.consumed+2 .. $];
            <span class="d_keyword">alias</span> test = charClass.fn;
        }
        <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern[0] == '\\')
        {
            <span class="d_keyword">alias</span> escapeSequence =
                regexCompileEscape!(pattern[1 .. pattern.length]);
            <span class="d_keyword">const</span> string token = pattern[0 .. escapeSequence.consumed+1];
            <span class="d_keyword">const</span> string next =
                pattern[escapeSequence.consumed+1 .. $];
            <span class="d_keyword">alias</span> test = escapeSequence.fn;
        }
        <span class="d_keyword">else</span>
        {
            <span class="d_keyword">const</span> string token = parseTextToken!(pattern);
            <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(token.length &gt; 0);
            <span class="d_keyword">const</span> string next = pattern[token.length .. $];
            <span class="d_keyword">alias</span> test = testText!(token);
        }

        <span class="d_keyword">alias</span> term = regexCompilePredicate!(test, next);
        <span class="d_keyword">const</span> string remaining = next[term.consumed .. next.length];

        <span class="d_keyword">alias</span> fn = regexCompileRecurse!(term,remaining).fn;
    }
    <span class="d_keyword">else</span>
        <span class="d_keyword">alias</span> fn = testEmpty!();
}

<span class="d_keyword">template</span> regexCompileRecurse(<span class="d_keyword">alias</span> term,string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pattern.length &gt; 0)
    {
        <span class="d_keyword">alias</span> next = regexCompile!(pattern);
        <span class="d_keyword">alias</span> fn = testUnion!(term.fn, next.fn);
    }
    <span class="d_keyword">else</span>
        <span class="d_keyword">alias</span> fn = term.fn;
}

<span class="d_comment">/// Utility function for parsing
</span><span class="d_keyword">template</span> isSpecial(string pattern)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (
        pattern[0] == '*' ||
        pattern[0] == '+' ||
        pattern[0] == '?' ||
        pattern[0] == '.' ||
        pattern[0] == '[' ||
        pattern[0] == '{' ||
        pattern[0] == '(' ||
        pattern[0] == ')' ||
        pattern[0] == '$' ||
        pattern[0] == '^' ||
        pattern[0] == '\\'
    )
        <span class="d_keyword">const</span> isSpecial = <span class="d_keyword">true</span>;
    <span class="d_keyword">else</span>
        <span class="d_keyword">const</span> isSpecial = <span class="d_keyword">false</span>;
}
</pre>

<h2>More Template Metaprogramming</h2>

    <ol>	<li>Tomasz Stachowiak's compile time <a href="http://h3.gd/ctrace/">raytracer</a>.</li>

	<li>Don Clugston's compile time <a href="http://www.99-bottles-of-beer.net/language-d-1212.html">99 Bottles of Beer</a>.</li>
    </ol>

<h2>References</h2>

	<p>[1] D programming language,
	see <a href="http://www.digitalmars.com/d/">http://www.digitalmars.com/d/</a>
	</p>

	<p>[2] Don Clugston's &pi; calculator, see
	<a href="http://trac.dsource.org/projects/ddl/browser/trunk/meta/demo/calcpi.d">http://trac.dsource.org/projects/ddl/browser/trunk/meta/demo/calcpi.d</a>
	</p>

	<p>[3] Don Clugston's decimaldigit and itoa,
	see <a href="http://trac.dsource.org/projects/ddl/browser/trunk/meta/conv.d">http://trac.dsource.org/projects/ddl/browser/trunk/meta/conv.d</a>
	</p>

	<p>[4] Eric Niebler's Boost.Xpressive regular expression template
	library is at <a href="http://boost-sandbox.sourceforge.net/libs/xpressive/doc/html/index.html">http://boost-sandbox.sourceforge.net/libs/xpressive/doc/html/index.html</a>
	</p>

	<p>[5] Eric Anderton's Regular Expression template library
	for D is at <a href="http://trac.dsource.org/projects/ddl/browser/trunk/meta/regex.d">http://trac.dsource.org/projects/ddl/browser/trunk/meta/regex.d</a>
	</p>

<h2>Acknowledgements</h2>

<p>I gratefully acknowledge the inspiration and assistance
of Don Clugston, Eric Anderton and Matthew Wilson.
</p>




</div>
<div id="copyright">Copyright &copy; 1999-2015 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Sun Sep 13 11:45:13 2015
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js">\x3C/script>');</script>
    <script type="text/javascript" src="js/dlang.js"></script>
    
    <script type="text/javascript" src="js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="js/run.js"></script>

<script type="text/javascript" src="js/run-main-website.js"></script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
</body>
</html>
