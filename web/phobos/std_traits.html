
<!DOCTYPE html>
<html lang="en-US">
<!--
    Copyright (c) 1999-2015 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
<meta charset="utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>std.traits - D Programming Language</title>
<link rel="stylesheet" href="../css/codemirror.css" />
<link rel="stylesheet" href="../css/style.css" />
<link rel="stylesheet" href="../css/print.css" media="print" />
<link rel="stylesheet" href="../css/cssmenu.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="shortcut icon" href="../favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.1, maximum-scale=10.0" />
</head>
<body id='std.traits' class='std'>
<script type="text/javascript">document.body.className += ' have-javascript';</script>
<div id="top">	<div id="header">		<a class="logo" href=".."><img id="logo" width="125" height="95" alt="D Logo" src="../images/dlogo.svg"></a>
		<span id="d-language-mobilehelper"><a href=".." id="d-language">D Programming Language</a></span>
	</div>
</div>
<div id="navigation">    <div id="search-box">        <form method="get" action="http://google.com/search">
            <input type="hidden" id="domains" name="domains" value="dlang.org" />
            <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
            <span id="search-query"><input id="q" name="q" placeholder="Search" tabindex="1000" /></span><span id="search-dropdown">                <select id="sitesearch" name="sitesearch" size="1">
                    <option value="dlang.org">Entire D Site</option>
                    <option selected value="dlang.org/phobos">Library Reference</option>
                    <option value="digitalmars.com/d/archives">Newsgroup Archives</option>
                </select>
            </span><span id="search-submit"><button type="submit"><i class="fa fa-search"></i><span>go</span></button></span>
        </form>
    </div>
    
<div id="cssmenu"><ul>    <li><a href='../index.html'><span>D Lib 2.067.1</span></a></li>
    <li><a href='../phobos-prerelease/index.html'><span>Prerelease Version</span></a></li>
    
<li><a href='object.html'><span><em class="tt">object</em></span></a></li>
<li class='has-sub'><a href='#'><span><em class="tt">std</em></span></a>
<ul><li>  <a href="std_algorithm.html" title="std.algorithm"><span class="d_inlinecode donthyphenate notranslate">algorithm</span></a><ul><li>    <a href="std_algorithm_comparison.html" title="std.algorithm.comparison"><span class="d_inlinecode donthyphenate notranslate">comparison</span></a></li><li>    <a href="std_algorithm_iteration.html" title="std.algorithm.iteration"><span class="d_inlinecode donthyphenate notranslate">iteration</span></a></li><li>    <a href="std_algorithm_mutation.html" title="std.algorithm.mutation"><span class="d_inlinecode donthyphenate notranslate">mutation</span></a></li><li>    <a href="std_algorithm_searching.html" title="std.algorithm.searching"><span class="d_inlinecode donthyphenate notranslate">searching</span></a></li><li>    <a href="std_algorithm_setops.html" title="std.algorithm.setops"><span class="d_inlinecode donthyphenate notranslate">setops</span></a></li><li>    <a href="std_algorithm_sorting.html" title="std.algorithm.sorting"><span class="d_inlinecode donthyphenate notranslate">sorting</span></a>
  </li></ul></li><li>  <a href="std_array.html" title="std.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>  <a href="std_ascii.html" title="std.ascii"><span class="d_inlinecode donthyphenate notranslate">ascii</span></a></li><li>  <a href="std_base64.html" title="std.base64"><span class="d_inlinecode donthyphenate notranslate">base64</span></a></li><li>  <a href="std_bigint.html" title="std.bigint"><span class="d_inlinecode donthyphenate notranslate">bigint</span></a></li><li>  <a href="std_bitmanip.html" title="std.bitmanip"><span class="d_inlinecode donthyphenate notranslate">bitmanip</span></a></li><li>  <a href="std_compiler.html" title="std.compiler"><span class="d_inlinecode donthyphenate notranslate">compiler</span></a></li><li>  <a href="std_complex.html" title="std.complex"><span class="d_inlinecode donthyphenate notranslate">complex</span></a></li><li>  <a href="std_concurrency.html" title="std.concurrency"><span class="d_inlinecode donthyphenate notranslate">concurrency</span></a></li><li>  <a href="std_container.html" title="std.container"><span class="d_inlinecode donthyphenate notranslate">container</span></a><ul><li>    <a href="std_container_array.html" title="std.container.array"><span class="d_inlinecode donthyphenate notranslate">array</span></a></li><li>    <a href="std_container_binaryheap.html" title="std.container.binaryheap"><span class="d_inlinecode donthyphenate notranslate">binaryheap</span></a></li><li>    <a href="std_container_dlist.html" title="std.container.dlist"><span class="d_inlinecode donthyphenate notranslate">dlist</span></a></li><li>    <a href="std_container_rbtree.html" title="std.container.rbtree"><span class="d_inlinecode donthyphenate notranslate">rbtree</span></a></li><li>    <a href="std_container_slist.html" title="std.container.slist"><span class="d_inlinecode donthyphenate notranslate">slist</span></a></li><li>    <a href="std_container_util.html" title="std.container.util"><span class="d_inlinecode donthyphenate notranslate">util</span></a>
  </li></ul></li><li>  <a href="std_conv.html" title="std.conv"><span class="d_inlinecode donthyphenate notranslate">conv</span></a></li><li>  <a href="std_cstream.html" title="std.cstream"><span class="d_inlinecode donthyphenate notranslate">cstream</span></a></li><li>  <a href="std_csv.html" title="std.csv"><span class="d_inlinecode donthyphenate notranslate">csv</span></a></li><li>  <a href="std_datetime.html" title="std.datetime"><span class="d_inlinecode donthyphenate notranslate">datetime</span></a></li><li>  <a href="std_demangle.html" title="std.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">digest</span></h7><ul><li>    <a href="std_digest_crc.html" title="std.digest.crc"><span class="d_inlinecode donthyphenate notranslate">crc</span></a></li><li>    <a href="std_digest_digest.html" title="std.digest.digest"><span class="d_inlinecode donthyphenate notranslate">digest</span></a></li><li>    <a href="std_digest_md.html" title="std.digest.md"><span class="d_inlinecode donthyphenate notranslate">md</span></a></li><li>    <a href="std_digest_ripemd.html" title="std.digest.ripemd"><span class="d_inlinecode donthyphenate notranslate">ripemd</span></a></li><li>    <a href="std_digest_sha.html" title="std.digest.sha"><span class="d_inlinecode donthyphenate notranslate">sha</span></a>
  </li></ul></li><li>  <a href="std_encoding.html" title="std.encoding"><span class="d_inlinecode donthyphenate notranslate">encoding</span></a></li><li>  <a href="std_exception.html" title="std.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">experimental</span></h7><ul><li>    <a href="std_experimental_logger.html" title="std.experimental.logger"><span class="d_inlinecode donthyphenate notranslate">logger</span></a><ul><li>      <a href="std_experimental_logger_core.html" title="std.experimental.logger.core"><span class="d_inlinecode donthyphenate notranslate">core</span></a></li><li>      <a href="std_experimental_logger_filelogger.html" title="std.experimental.logger.filelogger"><span class="d_inlinecode donthyphenate notranslate">filelogger</span></a></li><li>      <a href="std_experimental_logger_multilogger.html" title="std.experimental.logger.multilogger"><span class="d_inlinecode donthyphenate notranslate">multilogger</span></a></li><li>      <a href="std_experimental_logger_nulllogger.html" title="std.experimental.logger.nulllogger"><span class="d_inlinecode donthyphenate notranslate">nulllogger</span></a>
    </li></ul>
  </li></ul></li><li>  <a href="std_file.html" title="std.file"><span class="d_inlinecode donthyphenate notranslate">file</span></a></li><li>  <a href="std_format.html" title="std.format"><span class="d_inlinecode donthyphenate notranslate">format</span></a></li><li>  <a href="std_functional.html" title="std.functional"><span class="d_inlinecode donthyphenate notranslate">functional</span></a></li><li>  <a href="std_getopt.html" title="std.getopt"><span class="d_inlinecode donthyphenate notranslate">getopt</span></a></li><li>  <a href="std_json.html" title="std.json"><span class="d_inlinecode donthyphenate notranslate">json</span></a></li><li>  <a href="std_math.html" title="std.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="std_mathspecial.html" title="std.mathspecial"><span class="d_inlinecode donthyphenate notranslate">mathspecial</span></a></li><li>  <a href="std_metastrings.html" title="std.metastrings"><span class="d_inlinecode donthyphenate notranslate">metastrings</span></a></li><li>  <a href="std_mmfile.html" title="std.mmfile"><span class="d_inlinecode donthyphenate notranslate">mmfile</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">net</span></h7><ul><li>    <a href="std_net_curl.html" title="std.net.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="std_net_isemail.html" title="std.net.isemail"><span class="d_inlinecode donthyphenate notranslate">isemail</span></a>
  </li></ul></li><li>  <a href="std_numeric.html" title="std.numeric"><span class="d_inlinecode donthyphenate notranslate">numeric</span></a></li><li>  <a href="std_outbuffer.html" title="std.outbuffer"><span class="d_inlinecode donthyphenate notranslate">outbuffer</span></a></li><li>  <a href="std_parallelism.html" title="std.parallelism"><span class="d_inlinecode donthyphenate notranslate">parallelism</span></a></li><li>  <a href="std_path.html" title="std.path"><span class="d_inlinecode donthyphenate notranslate">path</span></a></li><li>  <a href="std_process.html" title="std.process"><span class="d_inlinecode donthyphenate notranslate">process</span></a></li><li>  <a href="std_random.html" title="std.random"><span class="d_inlinecode donthyphenate notranslate">random</span></a></li><li>  <a href="std_range.html" title="std.range"><span class="d_inlinecode donthyphenate notranslate">range</span></a><ul><li>    <a href="std_range_interfaces.html" title="std.range.interfaces"><span class="d_inlinecode donthyphenate notranslate">interfaces</span></a></li><li>    <a href="std_range_primitives.html" title="std.range.primitives"><span class="d_inlinecode donthyphenate notranslate">primitives</span></a>
  </li></ul></li><li>  <a href="std_regex.html" title="std.regex"><span class="d_inlinecode donthyphenate notranslate">regex</span></a></li><li>  <a href="std_signals.html" title="std.signals"><span class="d_inlinecode donthyphenate notranslate">signals</span></a></li><li>  <a href="std_socket.html" title="std.socket"><span class="d_inlinecode donthyphenate notranslate">socket</span></a></li><li>  <a href="std_socketstream.html" title="std.socketstream"><span class="d_inlinecode donthyphenate notranslate">socketstream</span></a></li><li>  <a href="std_stdint.html" title="std.stdint"><span class="d_inlinecode donthyphenate notranslate">stdint</span></a></li><li>  <a href="std_stdio.html" title="std.stdio"><span class="d_inlinecode donthyphenate notranslate">stdio</span></a></li><li>  <a href="std_stdiobase.html" title="std.stdiobase"><span class="d_inlinecode donthyphenate notranslate">stdiobase</span></a></li><li>  <a href="std_stream.html" title="std.stream"><span class="d_inlinecode donthyphenate notranslate">stream</span></a></li><li>  <a href="std_string.html" title="std.string"><span class="d_inlinecode donthyphenate notranslate">string</span></a></li><li>  <a href="std_syserror.html" title="std.syserror"><span class="d_inlinecode donthyphenate notranslate">syserror</span></a></li><li>  <a href="std_system.html" title="std.system"><span class="d_inlinecode donthyphenate notranslate">system</span></a></li><li>  <a href="std_traits.html" title="std.traits"><span class="d_inlinecode donthyphenate notranslate">traits</span></a></li><li>  <a href="std_typecons.html" title="std.typecons"><span class="d_inlinecode donthyphenate notranslate">typecons</span></a></li><li>  <a href="std_typetuple.html" title="std.typetuple"><span class="d_inlinecode donthyphenate notranslate">typetuple</span></a></li><li>  <a href="std_uni.html" title="std.uni"><span class="d_inlinecode donthyphenate notranslate">uni</span></a></li><li>  <a href="std_uri.html" title="std.uri"><span class="d_inlinecode donthyphenate notranslate">uri</span></a></li><li>  <a href="std_utf.html" title="std.utf"><span class="d_inlinecode donthyphenate notranslate">utf</span></a></li><li>  <a href="std_uuid.html" title="std.uuid"><span class="d_inlinecode donthyphenate notranslate">uuid</span></a></li><li>  <a href="std_variant.html" title="std.variant"><span class="d_inlinecode donthyphenate notranslate">variant</span></a></li><li>  <a href="std_xml.html" title="std.xml"><span class="d_inlinecode donthyphenate notranslate">xml</span></a></li><li>  <a href="std_zip.html" title="std.zip"><span class="d_inlinecode donthyphenate notranslate">zip</span></a></li><li>  <a href="std_zlib.html" title="std.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">etc</em></span></a>
<ul><li>  <h7><span class="d_inlinecode donthyphenate notranslate">c</span></h7><ul><li>    <a href="etc_c_curl.html" title="etc.c.curl"><span class="d_inlinecode donthyphenate notranslate">curl</span></a></li><li>    <a href="etc_c_sqlite3.html" title="etc.c.sqlite3"><span class="d_inlinecode donthyphenate notranslate">sqlite3</span></a></li><li>    <a href="etc_c_zlib.html" title="etc.c.zlib"><span class="d_inlinecode donthyphenate notranslate">zlib</span></a>
  </li></ul>
</li></ul>
<li class='has-sub'><a href='#'><span><em class="tt">core</em></span></a>
<ul><li>  <a href="core_atomic.html" title="core.atomic"><span class="d_inlinecode donthyphenate notranslate">atomic</span></a></li><li>  <a href="core_bitop.html" title="core.bitop"><span class="d_inlinecode donthyphenate notranslate">bitop</span></a></li><li>  <a href="core_checkedint.html" title="core.checkedint"><span class="d_inlinecode donthyphenate notranslate">checkedint</span></a></li><li>  <a href="core_cpuid.html" title="core.cpuid"><span class="d_inlinecode donthyphenate notranslate">cpuid</span></a></li><li>  <a href="core_demangle.html" title="core.demangle"><span class="d_inlinecode donthyphenate notranslate">demangle</span></a></li><li>  <a href="core_exception.html" title="core.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>  <a href="core_math.html" title="core.math"><span class="d_inlinecode donthyphenate notranslate">math</span></a></li><li>  <a href="core_memory.html" title="core.memory"><span class="d_inlinecode donthyphenate notranslate">memory</span></a></li><li>  <a href="core_runtime.html" title="core.runtime"><span class="d_inlinecode donthyphenate notranslate">runtime</span></a></li><li>  <a href="core_simd.html" title="core.simd"><span class="d_inlinecode donthyphenate notranslate">simd</span></a></li><li>  <h7><span class="d_inlinecode donthyphenate notranslate">sync</span></h7><ul><li>    <a href="core_sync_barrier.html" title="core.sync.barrier"><span class="d_inlinecode donthyphenate notranslate">barrier</span></a></li><li>    <a href="core_sync_condition.html" title="core.sync.condition"><span class="d_inlinecode donthyphenate notranslate">condition</span></a></li><li>    <a href="core_sync_config.html" title="core.sync.config"><span class="d_inlinecode donthyphenate notranslate">config</span></a></li><li>    <a href="core_sync_exception.html" title="core.sync.exception"><span class="d_inlinecode donthyphenate notranslate">exception</span></a></li><li>    <a href="core_sync_mutex.html" title="core.sync.mutex"><span class="d_inlinecode donthyphenate notranslate">mutex</span></a></li><li>    <a href="core_sync_rwmutex.html" title="core.sync.rwmutex"><span class="d_inlinecode donthyphenate notranslate">rwmutex</span></a></li><li>    <a href="core_sync_semaphore.html" title="core.sync.semaphore"><span class="d_inlinecode donthyphenate notranslate">semaphore</span></a>
  </li></ul></li><li>  <a href="core_thread.html" title="core.thread"><span class="d_inlinecode donthyphenate notranslate">thread</span></a></li><li>  <a href="core_time.html" title="core.time"><span class="d_inlinecode donthyphenate notranslate">time</span></a></li><li>  <a href="core_vararg.html" title="core.vararg"><span class="d_inlinecode donthyphenate notranslate">vararg</span></a>
</li></ul>
    <li><a href='http://code.dlang.org'><span>3rd Party Packages</span></a></li>
</ul></div>
</div>

<div class="hyphenate" id="content">    
<div id="tools">	<span class="tip">		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std/traits.d" class="button">Improve this page</a>
		<span >			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">		<a href="http://wiki.dlang.org/DocComments/Phobos/StdTraits" class="button">Page wiki</a>
		<span >			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>
    <h1>std.traits</h1>
    <div class="quickindex" id="quickindex"></div>
    <!--Generated by Ddoc from std/traits.d-->
<div class="summary">Templates which extract information about types and symbols at compile time.
</div>
<div class="description"><script type="text/javascript">inhibitQuickIndex = 1;</script>
<p></p>

 <div class="quickindex"> <table class="book"><caption></caption> <tr><th scope="col">Category</th> <th scope="col">Templates</th></tr>
 <tr><td>Symbol Name traits</td> <td>           <a href="#fullyQualifiedName"><span class="d_inlinecode donthyphenate notranslate">fullyQualifiedName</span></a>
           <a href="#moduleName"><span class="d_inlinecode donthyphenate notranslate">moduleName</span></a>
           <a href="#packageName"><span class="d_inlinecode donthyphenate notranslate">packageName</span></a>
 </td></tr>
 <tr><td>Function traits</td> <td>           <a href="#arity"><span class="d_inlinecode donthyphenate notranslate">arity</span></a>
           <a href="#functionAttributes"><span class="d_inlinecode donthyphenate notranslate">functionAttributes</span></a>
           <a href="#functionLinkage"><span class="d_inlinecode donthyphenate notranslate">functionLinkage</span></a>
           <a href="#FunctionTypeOf"><span class="d_inlinecode donthyphenate notranslate">FunctionTypeOf</span></a>
           <a href="#isSafe"><span class="d_inlinecode donthyphenate notranslate">isSafe</span></a>
           <a href="#isUnsafe"><span class="d_inlinecode donthyphenate notranslate">isUnsafe</span></a>
           <a href="#ParameterDefaultValueTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterDefaultValueTuple</span></a>
           <a href="#ParameterIdentifierTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterIdentifierTuple</span></a>
           <a href="#ParameterStorageClassTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterStorageClassTuple</span></a>
           <a href="#ParameterTypeTuple"><span class="d_inlinecode donthyphenate notranslate">ParameterTypeTuple</span></a>
           <a href="#ReturnType"><span class="d_inlinecode donthyphenate notranslate">ReturnType</span></a>
           <a href="#SetFunctionAttributes"><span class="d_inlinecode donthyphenate notranslate">SetFunctionAttributes</span></a>
           <a href="#variadicFunctionStyle"><span class="d_inlinecode donthyphenate notranslate">variadicFunctionStyle</span></a>
 </td></tr>
 <tr><td>Aggregate Type traits</td> <td>           <a href="#BaseClassesTuple"><span class="d_inlinecode donthyphenate notranslate">BaseClassesTuple</span></a>
           <a href="#BaseTypeTuple"><span class="d_inlinecode donthyphenate notranslate">BaseTypeTuple</span></a>
           <a href="#classInstanceAlignment"><span class="d_inlinecode donthyphenate notranslate">classInstanceAlignment</span></a>
           <a href="#EnumMembers"><span class="d_inlinecode donthyphenate notranslate">EnumMembers</span></a>
           <a href="#FieldNameTuple"><span class="d_inlinecode donthyphenate notranslate">FieldNameTuple</span></a>
           <a href="#FieldTypeTuple"><span class="d_inlinecode donthyphenate notranslate">FieldTypeTuple</span></a>
           <a href="#hasAliasing"><span class="d_inlinecode donthyphenate notranslate">hasAliasing</span></a>
           <a href="#hasElaborateAssign"><span class="d_inlinecode donthyphenate notranslate">hasElaborateAssign</span></a>
           <a href="#hasElaborateCopyConstructor"><span class="d_inlinecode donthyphenate notranslate">hasElaborateCopyConstructor</span></a>
           <a href="#hasElaborateDestructor"><span class="d_inlinecode donthyphenate notranslate">hasElaborateDestructor</span></a>
           <a href="#hasIndirections"><span class="d_inlinecode donthyphenate notranslate">hasIndirections</span></a>
           <a href="#hasMember"><span class="d_inlinecode donthyphenate notranslate">hasMember</span></a>
           <a href="#hasNested"><span class="d_inlinecode donthyphenate notranslate">hasNested</span></a>
           <a href="#hasUnsharedAliasing"><span class="d_inlinecode donthyphenate notranslate">hasUnsharedAliasing</span></a>
           <a href="#InterfacesTuple"><span class="d_inlinecode donthyphenate notranslate">InterfacesTuple</span></a>
           <a href="#isNested"><span class="d_inlinecode donthyphenate notranslate">isNested</span></a>
           <a href="#MemberFunctionsTuple"><span class="d_inlinecode donthyphenate notranslate">MemberFunctionsTuple</span></a>
           <a href="#RepresentationTypeTuple"><span class="d_inlinecode donthyphenate notranslate">RepresentationTypeTuple</span></a>
           <a href="#TemplateArgsOf"><span class="d_inlinecode donthyphenate notranslate">TemplateArgsOf</span></a>
           <a href="#TemplateOf"><span class="d_inlinecode donthyphenate notranslate">TemplateOf</span></a>
           <a href="#TransitiveBaseTypeTuple"><span class="d_inlinecode donthyphenate notranslate">TransitiveBaseTypeTuple</span></a>
 </td></tr>
 <tr><td>Type Conversion</td> <td>           <a href="#CommonType"><span class="d_inlinecode donthyphenate notranslate">CommonType</span></a>
           <a href="#ImplicitConversionTargets"><span class="d_inlinecode donthyphenate notranslate">ImplicitConversionTargets</span></a>
           <a href="#isAssignable"><span class="d_inlinecode donthyphenate notranslate">isAssignable</span></a>
           <a href="#isCovariantWith"><span class="d_inlinecode donthyphenate notranslate">isCovariantWith</span></a>
           <a href="#isImplicitlyConvertible"><span class="d_inlinecode donthyphenate notranslate">isImplicitlyConvertible</span></a>
 </td></tr>
 <!--<tr><td>SomethingTypeOf</td> <td>           <a href="#BooleanTypeOf"><span class="d_inlinecode donthyphenate notranslate">BooleanTypeOf</span></a>
           <a href="#IntegralTypeOf"><span class="d_inlinecode donthyphenate notranslate">IntegralTypeOf</span></a>
           <a href="#FloatingPointTypeOf"><span class="d_inlinecode donthyphenate notranslate">FloatingPointTypeOf</span></a>
           <a href="#NumericTypeOf"><span class="d_inlinecode donthyphenate notranslate">NumericTypeOf</span></a>
           <a href="#UnsignedTypeOf"><span class="d_inlinecode donthyphenate notranslate">UnsignedTypeOf</span></a>
           <a href="#SignedTypeOf"><span class="d_inlinecode donthyphenate notranslate">SignedTypeOf</span></a>
           <a href="#CharTypeOf"><span class="d_inlinecode donthyphenate notranslate">CharTypeOf</span></a>
           <a href="#StaticArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">StaticArrayTypeOf</span></a>
           <a href="#DynamicArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">DynamicArrayTypeOf</span></a>
           <a href="#ArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">ArrayTypeOf</span></a>
           <a href="#StringTypeOf"><span class="d_inlinecode donthyphenate notranslate">StringTypeOf</span></a>
           <a href="#AssocArrayTypeOf"><span class="d_inlinecode donthyphenate notranslate">AssocArrayTypeOf</span></a>
           <a href="#BuiltinTypeOf"><span class="d_inlinecode donthyphenate notranslate">BuiltinTypeOf</span></a>
 </td></tr>-->
 <tr><td>Categories of types</td> <td>           <a href="#isAggregateType"><span class="d_inlinecode donthyphenate notranslate">isAggregateType</span></a>
           <a href="#isArray"><span class="d_inlinecode donthyphenate notranslate">isArray</span></a>
           <a href="#isAssociativeArray"><span class="d_inlinecode donthyphenate notranslate">isAssociativeArray</span></a>
           <a href="#isBasicType"><span class="d_inlinecode donthyphenate notranslate">isBasicType</span></a>
           <a href="#isBoolean"><span class="d_inlinecode donthyphenate notranslate">isBoolean</span></a>
           <a href="#isBuiltinType"><span class="d_inlinecode donthyphenate notranslate">isBuiltinType</span></a>
           <a href="#isDynamicArray"><span class="d_inlinecode donthyphenate notranslate">isDynamicArray</span></a>
           <a href="#isFloatingPoint"><span class="d_inlinecode donthyphenate notranslate">isFloatingPoint</span></a>
           <a href="#isIntegral"><span class="d_inlinecode donthyphenate notranslate">isIntegral</span></a>
           <a href="#isNarrowString"><span class="d_inlinecode donthyphenate notranslate">isNarrowString</span></a>
           <a href="#isNumeric"><span class="d_inlinecode donthyphenate notranslate">isNumeric</span></a>
           <a href="#isPointer"><span class="d_inlinecode donthyphenate notranslate">isPointer</span></a>
           <a href="#isScalarType"><span class="d_inlinecode donthyphenate notranslate">isScalarType</span></a>
           <a href="#isSigned"><span class="d_inlinecode donthyphenate notranslate">isSigned</span></a>
           <a href="#isSomeChar"><span class="d_inlinecode donthyphenate notranslate">isSomeChar</span></a>
           <a href="#isSomeString"><span class="d_inlinecode donthyphenate notranslate">isSomeString</span></a>
           <a href="#isStaticArray"><span class="d_inlinecode donthyphenate notranslate">isStaticArray</span></a>
           <a href="#isUnsigned"><span class="d_inlinecode donthyphenate notranslate">isUnsigned</span></a>
 </td></tr>
 <tr><td>Type behaviours</td> <td>           <a href="#isAbstractClass"><span class="d_inlinecode donthyphenate notranslate">isAbstractClass</span></a>
           <a href="#isAbstractFunction"><span class="d_inlinecode donthyphenate notranslate">isAbstractFunction</span></a>
           <a href="#isCallable"><span class="d_inlinecode donthyphenate notranslate">isCallable</span></a>
           <a href="#isDelegate"><span class="d_inlinecode donthyphenate notranslate">isDelegate</span></a>
           <a href="#isExpressionTuple"><span class="d_inlinecode donthyphenate notranslate">isExpressionTuple</span></a>
           <a href="#isFinalClass"><span class="d_inlinecode donthyphenate notranslate">isFinalClass</span></a>
           <a href="#isFinalFunction"><span class="d_inlinecode donthyphenate notranslate">isFinalFunction</span></a>
           <a href="#isFunctionPointer"><span class="d_inlinecode donthyphenate notranslate">isFunctionPointer</span></a>
           <a href="#isInstanceOf"><span class="d_inlinecode donthyphenate notranslate">isInstanceOf</span></a>
           <a href="#isIterable"><span class="d_inlinecode donthyphenate notranslate">isIterable</span></a>
           <a href="#isMutable"><span class="d_inlinecode donthyphenate notranslate">isMutable</span></a>
           <a href="#isSomeFunction"><span class="d_inlinecode donthyphenate notranslate">isSomeFunction</span></a>
           <a href="#isTypeTuple"><span class="d_inlinecode donthyphenate notranslate">isTypeTuple</span></a>
 </td></tr>
 <tr><td>General Types</td> <td>           <a href="#ForeachType"><span class="d_inlinecode donthyphenate notranslate">ForeachType</span></a>
           <a href="#KeyType"><span class="d_inlinecode donthyphenate notranslate">KeyType</span></a>
           <a href="#Largest"><span class="d_inlinecode donthyphenate notranslate">Largest</span></a>
           <a href="#mostNegative"><span class="d_inlinecode donthyphenate notranslate">mostNegative</span></a>
           <a href="#OriginalType"><span class="d_inlinecode donthyphenate notranslate">OriginalType</span></a>
           <a href="#PointerTarget"><span class="d_inlinecode donthyphenate notranslate">PointerTarget</span></a>
           <a href="#Signed"><span class="d_inlinecode donthyphenate notranslate">Signed</span></a>
           <a href="#Unqual"><span class="d_inlinecode donthyphenate notranslate">Unqual</span></a>
           <a href="#Unsigned"><span class="d_inlinecode donthyphenate notranslate">Unsigned</span></a>
           <a href="#ValueType"><span class="d_inlinecode donthyphenate notranslate">ValueType</span></a>
 </td></tr>
 <tr><td>Misc</td> <td>           <a href="#mangledName"><span class="d_inlinecode donthyphenate notranslate">mangledName</span></a>
           <a href="#Select"><span class="d_inlinecode donthyphenate notranslate">Select</span></a>
           <a href="#select"><span class="d_inlinecode donthyphenate notranslate">select</span></a>
 </td></tr>
 </table>
 </div>

</div>
<div class="keyval License"><span class="key keyLicense">License:</span> <div class="val valLicense"><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</div></div>
<div class="keyval Authors"><span class="key keyAuthors">Authors:</span> <div class="val valAuthors"><a href="http://digitalmars.com">Walter Bright</a>,
            Tomasz Stachowiak (<span class="d_inlinecode donthyphenate notranslate">isExpressionTuple</span>),
            <a href="http://erdani.org">Andrei Alexandrescu</a>,
            Shin Fujishiro,
            <a href="http://octarineparrot.com">Robert Clipsham</a>,
            <a href="http://klickverbot.at">David Nadlinger</a>,
            Kenji Hara,
            Shoichi Kato
</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Source:</span>
<span class="phobos_src"><a class="https" href="https://github.com/D-Programming-Language/phobos/blob/master/std/traits.d">std/traits.d</a></span></div>

<dl><dt class="d_decl"><a name=".packageName"></a><div class="quickindex" id="quickindex.packageName"></div>template <a name="packageName"></a><span class="ddoc_psymbol">packageName</span>(alias T)</dt>
<dd><div class="summary">Get the full package name for the given symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">packageName</span>!<span class="d_psymbol">packageName</span> == <span class="d_string">"std"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".moduleName"></a><div class="quickindex" id="quickindex.moduleName"></div>template <a name="moduleName"></a><span class="ddoc_psymbol">moduleName</span>(alias T)</dt>
<dd><div class="summary">Get the module name (including package) for the given symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">moduleName</span>!<span class="d_psymbol">moduleName</span> == <span class="d_string">"std.traits"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".fullyQualifiedName"></a><div class="quickindex" id="quickindex.fullyQualifiedName"></div>template <a name="fullyQualifiedName"></a><span class="ddoc_psymbol">fullyQualifiedName</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Example:</span>
<pre class="d_code notranslate"><span class="d_keyword">module</span> myModule;
<span class="d_keyword">struct</span> MyStruct {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">fullyQualifiedName</span>!(<span class="d_keyword">const</span> MyStruct[]) == <span class="d_string">"const(myModule.MyStruct[])"</span>);
</pre>
</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">fullyQualifiedName</span>!<span class="d_psymbol">fullyQualifiedName</span> == <span class="d_string">"std.traits.fullyQualifiedName"</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ReturnType"></a><div class="quickindex" id="quickindex.ReturnType"></div>template <a name="ReturnType"></a><span class="ddoc_psymbol">ReturnType</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get the type of the return value from a function,
 a pointer to function, a delegate, a struct
 with an opCall, a pointer to a struct with an opCall,
 or a class with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>. Please note that <span class="d_keyword">ref</span>
 is not part of a type, but the attribute of the function
 (see template <a href="#functionAttributes"><span class="d_inlinecode donthyphenate notranslate">functionAttributes</span></a>).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo();
<span class="d_psymbol">ReturnType</span>!foo x;   <span class="d_comment">// x is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterTypeTuple"></a><div class="quickindex" id="quickindex.ParameterTypeTuple"></div>template <a name="ParameterTypeTuple"></a><span class="ddoc_psymbol">ParameterTypeTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the types of the parameters to a function, a pointer
to function, a delegate, a struct with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>, a pointer to a
struct with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>, or a class with an <span class="d_inlinecode donthyphenate notranslate">opCall</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>);
<span class="d_keyword">void</span> bar(<span class="d_psymbol">ParameterTypeTuple</span>!foo);      <span class="d_comment">// declares void bar(int, long);
</span><span class="d_keyword">void</span> abc(<span class="d_psymbol">ParameterTypeTuple</span>!foo[1]);   <span class="d_comment">// declares void abc(long);
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".arity"></a><div class="quickindex" id="quickindex.arity"></div>template <a name="arity"></a><span class="ddoc_psymbol">arity</span>(alias func) if (isCallable!func &amp;&amp; variadicFunctionStyle!func == Variadic.no)</dt>
<dd><div class="summary">Returns the number of arguments of function <span class="d_inlinecode donthyphenate notranslate">func</span>.
<a name="arity"></a><span class="ddoc_psymbol">arity</span> is undefined for variadic functions.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> foo(){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">arity</span>!foo==0);
<span class="d_keyword">void</span> bar(<span class="d_keyword">uint</span>){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">arity</span>!bar==1);
<span class="d_keyword">void</span> variadicFoo(<span class="d_keyword">uint</span>...){}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(compiles,<span class="d_psymbol">arity</span>!variadicFoo)==<span class="d_keyword">false</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterStorageClass"></a><div class="quickindex" id="quickindex.ParameterStorageClass"></div>enum <a name="ParameterStorageClass"></a><span class="ddoc_psymbol">ParameterStorageClass</span>: uint;
<br><a name=".ParameterStorageClassTuple"></a><div class="quickindex" id="quickindex.ParameterStorageClassTuple"></div>template <a name="ParameterStorageClassTuple"></a><span class="ddoc_psymbol">ParameterStorageClassTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns a tuple consisting of the storage classes of the parameters of a
function <span class="d_inlinecode donthyphenate notranslate">func</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> STC = ParameterStorageClass; <span class="d_comment">// shorten the enum name
</span>
<span class="d_keyword">void</span> func(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> ctx, <span class="d_keyword">out</span> <span class="d_keyword">real</span> result, <span class="d_keyword">real</span> param)
{
}
<span class="d_keyword">alias</span> pstc = <span class="d_psymbol">ParameterStorageClassTuple</span>!func;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc.length == 3); <span class="d_comment">// three parameters
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[0] == STC.ref_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[1] == STC.out_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(pstc[2] == STC.none);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".ParameterStorageClass.none"></a><div class="quickindex" id="quickindex.ParameterStorageClass.none"></div><a name="none"></a><span class="ddoc_psymbol">none</span><br><a name=".ParameterStorageClass.scope_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.scope_"></div><a name="scope_"></a><span class="ddoc_psymbol">scope_</span><br><a name=".ParameterStorageClass.out_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.out_"></div><a name="out_"></a><span class="ddoc_psymbol">out_</span><br><a name=".ParameterStorageClass.ref_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.ref_"></div><a name="ref_"></a><span class="ddoc_psymbol">ref_</span><br><a name=".ParameterStorageClass.lazy_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.lazy_"></div><a name="lazy_"></a><span class="ddoc_psymbol">lazy_</span><br><a name=".ParameterStorageClass.return_"></a><div class="quickindex" id="quickindex.ParameterStorageClass.return_"></div><a name="return_"></a><span class="ddoc_psymbol">return_</span></dt>
<dd><div class="summary">These flags can be bitwise OR-ed together to represent complex storage
 class.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ParameterIdentifierTuple"></a><div class="quickindex" id="quickindex.ParameterIdentifierTuple"></div>template <a name="ParameterIdentifierTuple"></a><span class="ddoc_psymbol">ParameterIdentifierTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the identifiers of the parameters to a function symbol.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> num, string name, <span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([<span class="d_psymbol">ParameterIdentifierTuple</span>!foo] == [<span class="d_string">"num"</span>, <span class="d_string">"name"</span>, <span class="d_string">""</span>]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ParameterDefaultValueTuple"></a><div class="quickindex" id="quickindex.ParameterDefaultValueTuple"></div>template <a name="ParameterDefaultValueTuple"></a><span class="ddoc_psymbol">ParameterDefaultValueTuple</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get, as a tuple, the default value of the parameters to a function symbol.
If a parameter doesn't have the default value, <span class="d_inlinecode donthyphenate notranslate">void</span> is returned instead.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> num, string name = <span class="d_string">"hello"</span>, <span class="d_keyword">int</span>[] = [1,2,3]);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ParameterDefaultValueTuple</span>!foo[0] == <span class="d_keyword">void</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   <span class="d_psymbol">ParameterDefaultValueTuple</span>!foo[1] == <span class="d_string">"hello"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   <span class="d_psymbol">ParameterDefaultValueTuple</span>!foo[2] == [1,2,3]);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".FunctionAttribute"></a><div class="quickindex" id="quickindex.FunctionAttribute"></div>enum <a name="FunctionAttribute"></a><span class="ddoc_psymbol">FunctionAttribute</span>: uint;
<br><a name=".functionAttributes"></a><div class="quickindex" id="quickindex.functionAttributes"></div>template <a name="functionAttributes"></a><span class="ddoc_psymbol">functionAttributes</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns the attributes attached to a function <span class="d_inlinecode donthyphenate notranslate">func</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits : <span class="d_psymbol">functionAttributes</span>, FunctionAttribute;

<span class="d_keyword">alias</span> FA = FunctionAttribute; <span class="d_comment">// shorten the enum name
</span>
<span class="d_keyword">real</span> func(<span class="d_keyword">real</span> x) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @safe
{
    <span class="d_keyword">return</span> x;
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.pure_);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.safe);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!(<span class="d_psymbol">functionAttributes</span>!func &amp; FA.trusted)); <span class="d_comment">// not @trusted
</span></pre>
</div></div>
<dl><dt class="d_decl"><a name=".FunctionAttribute.none"></a><div class="quickindex" id="quickindex.FunctionAttribute.none"></div><a name="none"></a><span class="ddoc_psymbol">none</span><br><a name=".FunctionAttribute.pure_"></a><div class="quickindex" id="quickindex.FunctionAttribute.pure_"></div><a name="pure_"></a><span class="ddoc_psymbol">pure_</span><br><a name=".FunctionAttribute.nothrow_"></a><div class="quickindex" id="quickindex.FunctionAttribute.nothrow_"></div><a name="nothrow_"></a><span class="ddoc_psymbol">nothrow_</span><br><a name=".FunctionAttribute.ref_"></a><div class="quickindex" id="quickindex.FunctionAttribute.ref_"></div><a name="ref_"></a><span class="ddoc_psymbol">ref_</span><br><a name=".FunctionAttribute.property"></a><div class="quickindex" id="quickindex.FunctionAttribute.property"></div><a name="property"></a><span class="ddoc_psymbol">property</span><br><a name=".FunctionAttribute.trusted"></a><div class="quickindex" id="quickindex.FunctionAttribute.trusted"></div><a name="trusted"></a><span class="ddoc_psymbol">trusted</span><br><a name=".FunctionAttribute.safe"></a><div class="quickindex" id="quickindex.FunctionAttribute.safe"></div><a name="safe"></a><span class="ddoc_psymbol">safe</span><br><a name=".FunctionAttribute.nogc"></a><div class="quickindex" id="quickindex.FunctionAttribute.nogc"></div><a name="nogc"></a><span class="ddoc_psymbol">nogc</span><br><a name=".FunctionAttribute.system"></a><div class="quickindex" id="quickindex.FunctionAttribute.system"></div><a name="system"></a><span class="ddoc_psymbol">system</span><br><a name=".FunctionAttribute.const_"></a><div class="quickindex" id="quickindex.FunctionAttribute.const_"></div><a name="const_"></a><span class="ddoc_psymbol">const_</span><br><a name=".FunctionAttribute.immutable_"></a><div class="quickindex" id="quickindex.FunctionAttribute.immutable_"></div><a name="immutable_"></a><span class="ddoc_psymbol">immutable_</span><br><a name=".FunctionAttribute.inout_"></a><div class="quickindex" id="quickindex.FunctionAttribute.inout_"></div><a name="inout_"></a><span class="ddoc_psymbol">inout_</span><br><a name=".FunctionAttribute.shared_"></a><div class="quickindex" id="quickindex.FunctionAttribute.shared_"></div><a name="shared_"></a><span class="ddoc_psymbol">shared_</span><br><a name=".FunctionAttribute.return_"></a><div class="quickindex" id="quickindex.FunctionAttribute.return_"></div><a name="return_"></a><span class="ddoc_psymbol">return_</span></dt>
<dd><div class="summary">These flags can be bitwise OR-ed together to represent a complex attribute.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".isSafe"></a><div class="quickindex" id="quickindex.isSafe"></div>template <a name="isSafe"></a><span class="ddoc_psymbol">isSafe</span>(alias func) if (isCallable!func)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">func</span> is <span class="d_inlinecode donthyphenate notranslate">@safe</span> or <span class="d_inlinecode donthyphenate notranslate">@trusted</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSafe</span>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSafe</span>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSafe</span>!mul);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isUnsafe"></a><div class="quickindex" id="quickindex.isUnsafe"></div>template <a name="isUnsafe"></a><span class="ddoc_psymbol">isUnsafe</span>(alias func)</dt>
<dd><div class="summary"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if <span class="d_inlinecode donthyphenate notranslate">func</span> is <span class="d_inlinecode donthyphenate notranslate">@system</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isUnsafe</span>!add);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isUnsafe</span>!sub);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isUnsafe</span>!mul);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".areAllSafe"></a><div class="quickindex" id="quickindex.areAllSafe"></div>template <a name="areAllSafe"></a><span class="ddoc_psymbol">areAllSafe</span>(funcs...) if (funcs.length &gt; 0)</dt>
<dd><div class="summary"><span class="red">Deprecated. It's badly named and provides redundant functionality. It was
also badly broken prior to 2.060 (bug# 8362), so any code which uses it
probably needs to be changed anyway. Please use <span class="d_inlinecode donthyphenate notranslate">allSatisfy(isSafe, ...)</span>
instead. This will be removed in June 2015.</span>
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> all functions are <span class="d_inlinecode donthyphenate notranslate">isSafe</span>.
<p></p>

Example
<pre class="d_code notranslate">@safe    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a+b;}
@trusted <span class="d_keyword">int</span> sub(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a-b;}
@system  <span class="d_keyword">int</span> mul(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b) {<span class="d_keyword">return</span> a*b;}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">areAllSafe</span>!(add, add));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">areAllSafe</span>!(add, sub));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">areAllSafe</span>!(sub, mul));
</pre>
</div>

</dd>
<dt class="d_decl"><a name=".functionLinkage"></a><div class="quickindex" id="quickindex.functionLinkage"></div>template <a name="functionLinkage"></a><span class="ddoc_psymbol">functionLinkage</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Returns the calling convention of function as a string.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.stdio : writeln, printf;

string a = <span class="d_psymbol">functionLinkage</span>!(writeln!(string, <span class="d_keyword">int</span>));
<span class="d_keyword">assert</span>(a == <span class="d_string">"D"</span>); <span class="d_comment">// extern(D)
</span>
<span class="d_keyword">auto</span> fp = &amp;printf;
string b = <span class="d_psymbol">functionLinkage</span>!fp;
<span class="d_keyword">assert</span>(b == <span class="d_string">"C"</span>); <span class="d_comment">// extern(C)
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Variadic"></a><div class="quickindex" id="quickindex.Variadic"></div>enum <a name="Variadic"></a><span class="ddoc_psymbol">Variadic</span>: int;
<br><a name=".variadicFunctionStyle"></a><div class="quickindex" id="quickindex.variadicFunctionStyle"></div>template <a name="variadicFunctionStyle"></a><span class="ddoc_psymbol">variadicFunctionStyle</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Determines what kind of variadic parameters function has.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">void</span> func() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">variadicFunctionStyle</span>!func == Variadic.no);

<span class="d_keyword">extern</span>(C) <span class="d_keyword">int</span> printf(<span class="d_keyword">in</span> <span class="d_keyword">char</span>*, ...);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">variadicFunctionStyle</span>!printf == Variadic.c);
</pre>
</div></div>
<dl><dt class="d_decl"><a name=".Variadic.no"></a><div class="quickindex" id="quickindex.Variadic.no"></div><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd><div class="summary">Function is not variadic.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.c"></a><div class="quickindex" id="quickindex.Variadic.c"></div><a name="c"></a><span class="ddoc_psymbol">c</span></dt>
<dd><div class="summary">Function is a C-style variadic function.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.d"></a><div class="quickindex" id="quickindex.Variadic.d"></div><a name="d"></a><span class="ddoc_psymbol">d</span></dt>
<dd><div class="summary">Function is a D-style variadic function, which uses
</div>
<div class="description">_argptr and _arguments.</div>

</dd>
<dt class="d_decl"><a name=".Variadic.typesafe"></a><div class="quickindex" id="quickindex.Variadic.typesafe"></div><a name="typesafe"></a><span class="ddoc_psymbol">typesafe</span></dt>
<dd><div class="summary">Function is a <a name="typesafe"></a><span class="ddoc_psymbol">typesafe</span> variadic function.</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".FunctionTypeOf"></a><div class="quickindex" id="quickindex.FunctionTypeOf"></div>template <a name="FunctionTypeOf"></a><span class="ddoc_psymbol">FunctionTypeOf</span>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt>
<dd><div class="summary">Get the function type from a callable object <span class="d_inlinecode donthyphenate notranslate">func</span>.
</div>
<div class="description">Using builtin <span class="d_inlinecode donthyphenate notranslate">typeof</span> on a property function yields the types of the
property value, not of the property function itself.  Still,
<span class="d_inlinecode donthyphenate notranslate"><a name="FunctionTypeOf"></a><span class="ddoc_psymbol">FunctionTypeOf</span></span> is able to obtain function types of properties.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Do not confuse function types with function pointer types; function types are
usually used for compile-time reflection purposes.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property { <span class="d_keyword">return</span> 0; }
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <span class="d_keyword">typeof</span>(C.value) == <span class="d_keyword">int</span> ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( <span class="d_psymbol">FunctionTypeOf</span>!(C.value) == <span class="d_keyword">function</span> ));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".SetFunctionAttributes"></a><div class="quickindex" id="quickindex.SetFunctionAttributes"></div>template <a name="SetFunctionAttributes"></a><span class="ddoc_psymbol">SetFunctionAttributes</span>(T, string linkage, uint attrs) if (isFunctionPointer!T || isDelegate!T)<br>template <a name="SetFunctionAttributes"></a><span class="ddoc_psymbol">SetFunctionAttributes</span>(T, string linkage, uint attrs) if (is(T == function))</dt>
<dd><div class="summary">Constructs a new function or delegate type with the same basic signature
 as the given one, but different attributes (including linkage).
</div>
<div class="description">This is especially useful for adding/removing attributes to/from types in
 generic code, where the actual type name cannot be spelt out.

</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">T</td>
<td class="param_desc">The base type.</td></tr>
<tr class="param"><td class="param_id">linkage</td>
<td class="param_desc">The desired linkage of the result type.</td></tr>
<tr class="param"><td class="param_id">attrs</td>
<td class="param_desc">The desired <a href="#FunctionAttribute"><span class="d_inlinecode donthyphenate notranslate">FunctionAttribute</span></a>s of the result type.</td></tr>
</table></div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> ExternC(T) = <span class="d_psymbol">SetFunctionAttributes</span>!(T, <span class="d_string">"C"</span>, functionAttributes!T);

<span class="d_keyword">auto</span> assumePure(T)(T t)
    <span class="d_keyword">if</span> (isFunctionPointer!T || isDelegate!T)
{
    <span class="d_keyword">enum</span> attrs = functionAttributes!T | FunctionAttribute.pure_;
    <span class="d_keyword">return</span> <span class="d_keyword">cast</span>(<span class="d_psymbol">SetFunctionAttributes</span>!(T, functionLinkage!T, attrs)) t;
}
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isNested"></a><div class="quickindex" id="quickindex.isNested"></div>template <a name="isNested"></a><span class="ddoc_psymbol">isNested</span>(T) if (is(T == class) || is(T == struct) || is(T == union))</dt>
<dd><div class="summary">Determines whether <span class="d_inlinecode donthyphenate notranslate">T</span> has its own context pointer.
<span class="d_inlinecode donthyphenate notranslate">T</span> must be either <span class="d_inlinecode donthyphenate notranslate">class</span>, <span class="d_inlinecode donthyphenate notranslate">struct</span>, or <span class="d_inlinecode donthyphenate notranslate">union</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isNested</span>!S);

<span class="d_keyword">int</span> i;
<span class="d_keyword">struct</span> NestedStruct { <span class="d_keyword">void</span> f() { ++i; } }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isNested</span>!NestedStruct);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasNested"></a><div class="quickindex" id="quickindex.hasNested"></div>template <a name="hasNested"></a><span class="ddoc_psymbol">hasNested</span>(T)</dt>
<dd><div class="summary">Determines whether <span class="d_inlinecode donthyphenate notranslate">T</span> or any of its representation types
have a context pointer.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S { }

<span class="d_keyword">int</span> i;
<span class="d_keyword">struct</span> NS { <span class="d_keyword">void</span> f() { ++i; } }

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasNested</span>!(S[2]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasNested</span>!(NS[2]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".FieldTypeTuple"></a><div class="quickindex" id="quickindex.FieldTypeTuple"></div>template <a name="FieldTypeTuple"></a><span class="ddoc_psymbol">FieldTypeTuple</span>(T)</dt>
<dd><div class="summary">Get as a typetuple the types of the fields of a struct, class, or union.
 This consists of the fields that take up memory space,
 excluding the hidden fields like the virtual function
 table pointer or a context pointer for nested types.
 If <span class="d_inlinecode donthyphenate notranslate">T</span> isn't a struct, class, or union returns typetuple
 with one element <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">FieldTypeTuple</span>!S == TypeTuple!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".FieldNameTuple"></a><div class="quickindex" id="quickindex.FieldNameTuple"></div>template <a name="FieldNameTuple"></a><span class="ddoc_psymbol">FieldNameTuple</span>(T)</dt>
<dd><div class="summary">Get as an expression tuple the names of the fields of a struct, class, or
 union. This consists of the fields that take up memory space, excluding the
 hidden fields like the virtual function table pointer or a context pointer
 for nested types. If <span class="d_inlinecode donthyphenate notranslate">T</span> isn't a struct, class, or union returns an
 expression tuple with an empty string.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">FieldNameTuple</span>!S == TypeTuple!(<span class="d_string">"x"</span>, <span class="d_string">"y"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">FieldNameTuple</span>!<span class="d_keyword">int</span> == TypeTuple!<span class="d_string">""</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".RepresentationTypeTuple"></a><div class="quickindex" id="quickindex.RepresentationTypeTuple"></div>template <a name="RepresentationTypeTuple"></a><span class="ddoc_psymbol">RepresentationTypeTuple</span>(T)</dt>
<dd><div class="summary">Get the primitive types of the fields of a struct or class, in
topological order.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; <span class="d_keyword">float</span> b; }
<span class="d_keyword">struct</span> S2 { <span class="d_keyword">char</span>[] a; <span class="d_keyword">union</span> { S1 b; S1 * c; } }
<span class="d_keyword">alias</span> R = <span class="d_psymbol">RepresentationTypeTuple</span>!S2;
<span class="d_keyword">assert</span>(R.length == 4
    &amp;&amp; <span class="d_keyword">is</span>(R[0] == <span class="d_keyword">char</span>[]) &amp;&amp; <span class="d_keyword">is</span>(R[1] == <span class="d_keyword">int</span>)
    &amp;&amp; <span class="d_keyword">is</span>(R[2] == <span class="d_keyword">float</span>) &amp;&amp; <span class="d_keyword">is</span>(R[3] == S1*));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasAliasing"></a><div class="quickindex" id="quickindex.hasAliasing"></div>template <a name="hasAliasing"></a><span class="ddoc_psymbol">hasAliasing</span>(T...)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span> and <span class="d_inlinecode donthyphenate notranslate">U</span>
is not immutable;</li> <li>an array <span class="d_inlinecode donthyphenate notranslate">U[]</span> and <span class="d_inlinecode donthyphenate notranslate">U</span> is not
immutable;</li> <li>a reference to a class or interface type <span class="d_inlinecode donthyphenate notranslate">C</span> and <span class="d_inlinecode donthyphenate notranslate">C</span> is
not immutable.</li> <li>an associative array that is not immutable.</li>
<li>a delegate.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; Object b; }
<span class="d_keyword">struct</span> S2 { string a; }
<span class="d_keyword">struct</span> S3 { <span class="d_keyword">int</span> a; <span class="d_keyword">immutable</span> Object b; }
<span class="d_keyword">struct</span> S4 { <span class="d_keyword">float</span>[3] vals; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasAliasing</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasAliasing</span>!S4);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasIndirections"></a><div class="quickindex" id="quickindex.hasIndirections"></div>template <a name="hasIndirections"></a><span class="ddoc_psymbol">hasIndirections</span>(T)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span>;</li> <li>an
array <span class="d_inlinecode donthyphenate notranslate">U[]</span>;</li> <li>a reference to a class type <span class="d_inlinecode donthyphenate notranslate">C</span>.</li>
<li>an associative array.</li> <li>a delegate.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">int</span>[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() <span class="d_keyword">immutable</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>())));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() <span class="d_keyword">immutable</span>)));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span> <span class="d_keyword">function</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">void</span>*[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasIndirections</span>!(<span class="d_keyword">byte</span>[1]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasUnsharedAliasing"></a><div class="quickindex" id="quickindex.hasUnsharedAliasing"></div>template <a name="hasUnsharedAliasing"></a><span class="ddoc_psymbol">hasUnsharedAliasing</span>(T...)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span>'s representation includes at
least one of the following: <ol><li>a raw pointer <span class="d_inlinecode donthyphenate notranslate">U*</span> and <span class="d_inlinecode donthyphenate notranslate">U</span>
is not immutable or shared;</li> <li>an array <span class="d_inlinecode donthyphenate notranslate">U[]</span> and <span class="d_inlinecode donthyphenate notranslate">U</span> is not
immutable or shared;</li> <li>a reference to a class type <span class="d_inlinecode donthyphenate notranslate">C</span> and
<span class="d_inlinecode donthyphenate notranslate">C</span> is not immutable or shared.</li> <li>an associative array that is not
immutable or shared.</li> <li>a delegate that is not shared.</li></ol></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> a; Object b; }
<span class="d_keyword">struct</span> S2 { string a; }
<span class="d_keyword">struct</span> S3 { <span class="d_keyword">int</span> a; <span class="d_keyword">immutable</span> Object b; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasUnsharedAliasing</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S3);

<span class="d_keyword">struct</span> S4 { <span class="d_keyword">int</span> a; <span class="d_keyword">shared</span> Object b; }
<span class="d_keyword">struct</span> S5 { <span class="d_keyword">char</span>[] a; }
<span class="d_keyword">struct</span> S6 { <span class="d_keyword">shared</span> <span class="d_keyword">char</span>[] b; }
<span class="d_keyword">struct</span> S7 { <span class="d_keyword">float</span>[3] vals; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasUnsharedAliasing</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasUnsharedAliasing</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateCopyConstructor"></a><div class="quickindex" id="quickindex.hasElaborateCopyConstructor"></div>template <a name="hasElaborateCopyConstructor"></a><span class="ddoc_psymbol">hasElaborateCopyConstructor</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type embedded directly in the representation of <span class="d_inlinecode donthyphenate notranslate">S</span>
 defines an elaborate copy constructor. Elaborate copy constructors are
 introduced by defining <span class="d_inlinecode donthyphenate notranslate">this(this)</span> for a <span class="d_inlinecode donthyphenate notranslate">struct</span>.
</div>
<div class="description">Classes and unions never have elaborate copy constructors.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { <span class="d_keyword">this</span>(<span class="d_keyword">this</span>) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S2 field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S4 { S3[1] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S5 { S3[] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S6 { S3[0] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S7 { @disable <span class="d_keyword">this</span>(); S3 field; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!(<span class="d_keyword">immutable</span> S2));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!(S3[0]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateCopyConstructor</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateCopyConstructor</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateAssign"></a><div class="quickindex" id="quickindex.hasElaborateAssign"></div>template <a name="hasElaborateAssign"></a><span class="ddoc_psymbol">hasElaborateAssign</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type directly embedded in the representation of <span class="d_inlinecode donthyphenate notranslate">S</span>
   defines an elaborate assignment. Elaborate assignments are introduced by
   defining <span class="d_inlinecode donthyphenate notranslate">opAssign(typeof(this))</span> or <span class="d_inlinecode donthyphenate notranslate">opAssign(ref typeof(this))</span>
   for a <span class="d_inlinecode donthyphenate notranslate">struct</span> or when there is a compiler-generated <span class="d_inlinecode donthyphenate notranslate">opAssign</span>.
</div>
<div class="description">A type <span class="d_inlinecode donthyphenate notranslate">S</span> gets compiler-generated <span class="d_inlinecode donthyphenate notranslate">opAssign</span> in case it has
   an elaborate copy constructor or elaborate destructor.
<p></p>

   Classes and unions never have elaborate assignments.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Structs with (possibly nested) postblit operator(s) will have a
   hidden yet elaborate compiler generated assignment operator (unless
   explicitly disabled).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S  { <span class="d_keyword">void</span> opAssign(S) {} }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!(<span class="d_keyword">const</span>(S)));

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { <span class="d_keyword">void</span> opAssign(<span class="d_keyword">ref</span> S1) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { <span class="d_keyword">void</span> opAssign(<span class="d_keyword">int</span>) {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S s; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateAssign</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateAssign</span>!(S3[0]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasElaborateDestructor"></a><div class="quickindex" id="quickindex.hasElaborateDestructor"></div>template <a name="hasElaborateDestructor"></a><span class="ddoc_psymbol">hasElaborateDestructor</span>(S)</dt>
<dd><div class="summary">True if <span class="d_inlinecode donthyphenate notranslate">S</span> or any type directly embedded in the representation
   of <span class="d_inlinecode donthyphenate notranslate">S</span> defines an elaborate destructor. Elaborate destructors
   are introduced by defining <span class="d_inlinecode donthyphenate notranslate">~this()</span> for a <span class="d_inlinecode donthyphenate notranslate">   struct</span>.
</div>
<div class="description">Classes and unions never have elaborate destructors, even
   though classes may define <span class="d_inlinecode donthyphenate notranslate">~this()</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!<span class="d_keyword">int</span>);

<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S1 { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S2 { ~<span class="d_keyword">this</span>() {} }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S3 { S2 field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S4 { S3[1] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S5 { S3[] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S6 { S3[0] field; }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> S7 { @disable <span class="d_keyword">this</span>(); S3 field; }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!(<span class="d_keyword">immutable</span> S2));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S3);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!(S3[1]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!(S3[0]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S4);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S5);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasElaborateDestructor</span>!S6);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">hasElaborateDestructor</span>!S7);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".hasMember"></a><div class="quickindex" id="quickindex.hasMember"></div>template <a name="hasMember"></a><span class="ddoc_psymbol">hasMember</span>(T, string name)</dt>
<dd><div class="summary">Yields <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if and only if <span class="d_inlinecode donthyphenate notranslate">T</span> is an aggregate that defines
   a symbol called <span class="d_inlinecode donthyphenate notranslate">name</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">hasMember</span>!(<span class="d_keyword">int</span>, <span class="d_string">"blah"</span>));
<span class="d_keyword">struct</span> S1 { <span class="d_keyword">int</span> blah; }
<span class="d_keyword">struct</span> S2 { <span class="d_keyword">int</span> blah(){ <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">class</span> C1 { <span class="d_keyword">int</span> blah; }
<span class="d_keyword">class</span> C2 { <span class="d_keyword">int</span> blah(){ <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(S1, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(S2, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(C1, <span class="d_string">"blah"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">hasMember</span>!(C2, <span class="d_string">"blah"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".EnumMembers"></a><div class="quickindex" id="quickindex.EnumMembers"></div>template <a name="EnumMembers"></a><span class="ddoc_psymbol">EnumMembers</span>(E) if (is(E == enum))</dt>
<dd><div class="summary">Retrieves the members of an enumerated type <span class="d_inlinecode donthyphenate notranslate">enum E</span>.
</div>
<div class="keyval Parameters"><span class="key keyParameters">Parameters:</span> <div class="val valParameters"><table class=params><tr class="param"><td class="param_id">E</td>
<td class="param_desc">An enumerated type. <span class="d_inlinecode donthyphenate notranslate">E</span> may have duplicated values.</td></tr>
</table></div></div>
<div class="keyval Returns"><span class="key keyReturns">Returns:</span> <div class="val valReturns">Static tuple composed of the members of the enumerated type <span class="d_inlinecode donthyphenate notranslate">E</span>.
 The members are arranged in the same order as declared in <span class="d_inlinecode donthyphenate notranslate">E</span>.

</div></div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
An enum can have multiple members which have the same value. If you want
 to use <a name="EnumMembers"></a><span class="ddoc_psymbol">EnumMembers</span> to e.g. generate switch cases at compile-time,
 you should use the <span class="libref"><a href="http://dlang.org/phobos/std_typetuple.html#NoDuplicates"><span class="d_inlinecode donthyphenate notranslate">std.typetuple.NoDuplicates</span></a></span> template to avoid
 generating duplicate switch cases.

</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
 Returned values are strictly typed with <span class="d_inlinecode donthyphenate notranslate">E</span>. Thus, the following code
 does not work without the explicit cast:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> E : <span class="d_keyword">int</span> { a, b, c }
<span class="d_keyword">int</span>[] abc = <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>[]) [ <span class="d_psymbol">EnumMembers</span>!E ];
</pre>
 Cast is not necessary if the type of the variable is inferred. See the
 example below.

</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"> Creating an array of enumerated values:
<pre class="d_code notranslate"><span class="d_keyword">enum</span> Sqrts : <span class="d_keyword">real</span>
{
    one   = 1,
    two   = 1.41421,
    three = 1.73205,
}
<span class="d_keyword">auto</span> sqrts = [ <span class="d_psymbol">EnumMembers</span>!Sqrts ];
<span class="d_keyword">assert</span>(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);
</pre>
<p></p>

 A generic function <span class="d_inlinecode donthyphenate notranslate">rank(v)</span> in the following example uses this
 template for finding a member <span class="d_inlinecode donthyphenate notranslate">e</span> in an enumerated type <span class="d_inlinecode donthyphenate notranslate">E</span>.
<pre class="d_code notranslate"><span class="d_comment">// Returns i if e is the i-th enumerator of E.
</span>size_t rank(E)(E e)
    <span class="d_keyword">if</span> (<span class="d_keyword">is</span>(E == <span class="d_keyword">enum</span>))
{
    <span class="d_keyword">foreach</span> (i, member; <span class="d_psymbol">EnumMembers</span>!E)
    {
        <span class="d_keyword">if</span> (e == member)
            <span class="d_keyword">return</span> i;
    }
    <span class="d_keyword">assert</span>(0, <span class="d_string">"Not an enum member"</span>);
}

<span class="d_keyword">enum</span> Mode
{
    read  = 1,
    write = 2,
    map   = 4,
}
<span class="d_keyword">assert</span>(rank(Mode.read ) == 0);
<span class="d_keyword">assert</span>(rank(Mode.write) == 1);
<span class="d_keyword">assert</span>(rank(Mode.map  ) == 2);
</pre>
</div></div>

</dd>
<dt class="d_decl"><a name=".BaseTypeTuple"></a><div class="quickindex" id="quickindex.BaseTypeTuple"></div>template <a name="BaseTypeTuple"></a><span class="ddoc_psymbol">BaseTypeTuple</span>(A)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of the base class and base interfaces of
 this class or interface. <span class="d_param"><a name="BaseTypeTuple"></a><span class="ddoc_psymbol">BaseTypeTuple</span>!Object</span> returns
 the empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I1 { }
<span class="d_keyword">interface</span> I2 { }
<span class="d_keyword">interface</span> I12 : I1, I2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseTypeTuple</span>!I12 == TypeTuple!(I1, I2)));

<span class="d_keyword">interface</span> I3 : I1 { }
<span class="d_keyword">interface</span> I123 : I1, I2, I3 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseTypeTuple</span>!I123 == TypeTuple!(I1, I2, I3)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".BaseClassesTuple"></a><div class="quickindex" id="quickindex.BaseClassesTuple"></div>template <a name="BaseClassesTuple"></a><span class="ddoc_psymbol">BaseClassesTuple</span>(T) if (is(T == class))</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> base classes of this class,
 in decreasing order. Interfaces are not included. <span class="d_param"> <a name="BaseClassesTuple"></a><span class="ddoc_psymbol">BaseClassesTuple</span>!Object</span> yields the empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C1 { }
<span class="d_keyword">class</span> C2 : C1 { }
<span class="d_keyword">class</span> C3 : C2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">BaseClassesTuple</span>!Object.length);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C1 == TypeTuple!(Object)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C2 == TypeTuple!(C1, Object)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">BaseClassesTuple</span>!C3 == TypeTuple!(C2, C1, Object)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">BaseClassesTuple</span>!Object.length);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".InterfacesTuple"></a><div class="quickindex" id="quickindex.InterfacesTuple"></div>template <a name="InterfacesTuple"></a><span class="ddoc_psymbol">InterfacesTuple</span>(T)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> interfaces directly or
 indirectly inherited by this class or interface. Interfaces do not
 repeat if multiply implemented. <span class="d_param"><a name="InterfacesTuple"></a><span class="ddoc_psymbol">InterfacesTuple</span>!Object</span>
 yields the empty type tuple.</div>

</dd>
<dt class="d_decl"><a name=".TransitiveBaseTypeTuple"></a><div class="quickindex" id="quickindex.TransitiveBaseTypeTuple"></div>template <a name="TransitiveBaseTypeTuple"></a><span class="ddoc_psymbol">TransitiveBaseTypeTuple</span>(T)</dt>
<dd><div class="summary">Get a <span class="d_param">TypeTuple</span> of <i>all</i> base classes of <span class="d_param"> T</span>, in decreasing order, followed by <span class="d_param">T</span>'s
 interfaces. <span class="d_param"><a name="TransitiveBaseTypeTuple"></a><span class="ddoc_psymbol">TransitiveBaseTypeTuple</span>!Object</span> yields the
 empty type tuple.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> J1 {}
<span class="d_keyword">interface</span> J2 {}
<span class="d_keyword">class</span> B1 {}
<span class="d_keyword">class</span> B2 : B1, J1, J2 {}
<span class="d_keyword">class</span> B3 : B2, J1 {}
<span class="d_keyword">alias</span> TL = <span class="d_psymbol">TransitiveBaseTypeTuple</span>!B3;
<span class="d_keyword">assert</span>(TL.length == 5);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[0] == B2));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[1] == B1));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[2] == Object));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[3] == J1));
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span> (TL[4] == J2));

<span class="d_keyword">assert</span>(<span class="d_psymbol">TransitiveBaseTypeTuple</span>!Object.length == 0);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".MemberFunctionsTuple"></a><div class="quickindex" id="quickindex.MemberFunctionsTuple"></div>template <a name="MemberFunctionsTuple"></a><span class="ddoc_psymbol">MemberFunctionsTuple</span>(C, string name) if (is(C == class) || is(C == interface))</dt>
<dd><div class="summary">Returns a tuple of non-static functions with the name <span class="d_inlinecode donthyphenate notranslate">name</span> declared in the
class or interface <span class="d_inlinecode donthyphenate notranslate">C</span>.  Covariant duplicates are shrunk into the most
derived one.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { I foo(); }
<span class="d_keyword">class</span> B
{
    <span class="d_keyword">real</span> foo(<span class="d_keyword">real</span> v) { <span class="d_keyword">return</span> v; }
}
<span class="d_keyword">class</span> C : B, I
{
    <span class="d_keyword">override</span> C foo() { <span class="d_keyword">return</span> <span class="d_keyword">this</span>; } <span class="d_comment">// covariant overriding of I.foo()
</span>}
<span class="d_keyword">alias</span> <span class="d_psymbol">MemberFunctionsTuple</span>!(C, <span class="d_string">"foo"</span>) foos;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(foos.length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[0], C.foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isSame, foos[1], B.foo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".TemplateOf"></a><div class="quickindex" id="quickindex.TemplateOf"></div>template <a name="TemplateOf"></a><span class="ddoc_psymbol">TemplateOf</span>(alias T : Base!Args, alias Base, Args...)</dt>
<dd><div class="summary">Returns an alias to the template that <span class="d_inlinecode donthyphenate notranslate">T</span> is an instance of.</div>

</dd>
<dt class="d_decl"><a name=".TemplateArgsOf"></a><div class="quickindex" id="quickindex.TemplateArgsOf"></div>template <a name="TemplateArgsOf"></a><span class="ddoc_psymbol">TemplateArgsOf</span>(alias T : Base!Args, alias Base, Args...)<br>template <a name="TemplateArgsOf"></a><span class="ddoc_psymbol">TemplateArgsOf</span>(T : Base!Args, alias Base, Args...)</dt>
<dd><div class="summary">Returns a <span class="d_inlinecode donthyphenate notranslate">TypeTuple</span> of the template arguments used to instantiate <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> Foo(T, U) {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">TemplateArgsOf</span>!(Foo!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>)) == TypeTuple!(<span class="d_keyword">int</span>, <span class="d_keyword">real</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".classInstanceAlignment"></a><div class="quickindex" id="quickindex.classInstanceAlignment"></div>template <a name="classInstanceAlignment"></a><span class="ddoc_psymbol">classInstanceAlignment</span>(T) if (is(T == class))</dt>
<dd><div class="summary">Returns class instance alignment.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> A { <span class="d_keyword">byte</span> b; }
<span class="d_keyword">class</span> B { <span class="d_keyword">long</span> l; }

<span class="d_comment">// As class instance always has a hidden pointer
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">classInstanceAlignment</span>!A == (<span class="d_keyword">void</span>*).alignof);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">classInstanceAlignment</span>!B == <span class="d_keyword">long</span>.alignof);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".CommonType"></a><div class="quickindex" id="quickindex.CommonType"></div>template <a name="CommonType"></a><span class="ddoc_psymbol">CommonType</span>(T...)</dt>
<dd><div class="summary">Get the type that all types can be implicitly converted to. Useful
e.g. in figuring out an array type from a bunch of initializing
values. Returns <span class="d_param">void</span> if passed an empty list, or if the
types have no common type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> X = <span class="d_psymbol">CommonType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>, <span class="d_keyword">short</span>);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(X == <span class="d_keyword">long</span>));
<span class="d_keyword">alias</span> Y = <span class="d_psymbol">CommonType</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">char</span>[], <span class="d_keyword">short</span>);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Y == <span class="d_keyword">void</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ImplicitConversionTargets"></a><div class="quickindex" id="quickindex.ImplicitConversionTargets"></div>template <a name="ImplicitConversionTargets"></a><span class="ddoc_psymbol">ImplicitConversionTargets</span>(T)</dt>
<dd><div class="summary">Returns a tuple with all possible target types of an implicit
 conversion of a value of type <span class="d_param">T</span>.
</div>
<div class="description">Important note:
<p></p>

 The possible targets are computed more conservatively than the D
 2.005 compiler does, eliminating all dangerous conversions. For
 example, <span class="d_param"><a name="ImplicitConversionTargets"></a><span class="ddoc_psymbol">ImplicitConversionTargets</span>!double</span> does not
 include <span class="d_param">float</span>.</div>

</dd>
<dt class="d_decl"><a name=".isImplicitlyConvertible"></a><div class="quickindex" id="quickindex.isImplicitlyConvertible"></div>template <a name="isImplicitlyConvertible"></a><span class="ddoc_psymbol">isImplicitlyConvertible</span>(From, To)</dt>
<dd><div class="summary">Is <span class="d_inlinecode donthyphenate notranslate">From</span> implicitly convertible to <span class="d_inlinecode donthyphenate notranslate">To</span>?</div>

</dd>
<dt class="d_decl"><a name=".isAssignable"></a><div class="quickindex" id="quickindex.isAssignable"></div>template <a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span>(Lhs, Rhs = Lhs)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> iff a value of type <span class="d_inlinecode donthyphenate notranslate">Rhs</span> can be assigned to a variable of
type <span class="d_inlinecode donthyphenate notranslate">Lhs</span>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span></span> returns whether both an lvalue and rvalue can be assigned.
<p></p>

If you omit <span class="d_inlinecode donthyphenate notranslate">Rhs</span>, <span class="d_inlinecode donthyphenate notranslate"><a name="isAssignable"></a><span class="ddoc_psymbol">isAssignable</span></span> will check identity assignable of <span class="d_inlinecode donthyphenate notranslate">Lhs</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">long</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">long</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)[], string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(string, <span class="d_keyword">char</span>[]));

<span class="d_comment">// int is assignable to int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAssignable</span>!<span class="d_keyword">int</span>);

<span class="d_comment">// immutable int is not assignable to immutable int
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAssignable</span>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isCovariantWith"></a><div class="quickindex" id="quickindex.isCovariantWith"></div>template <a name="isCovariantWith"></a><span class="ddoc_psymbol">isCovariantWith</span>(F, G) if (is(F == function) &amp;&amp; is(G == function))</dt>
<dd><div class="summary">Determines whether the function type <span class="d_inlinecode donthyphenate notranslate">F</span> is covariant with <span class="d_inlinecode donthyphenate notranslate">G</span>, i.e.,
functions of the type <span class="d_inlinecode donthyphenate notranslate">F</span> can override ones of the type <span class="d_inlinecode donthyphenate notranslate">G</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { I clone(); }
<span class="d_keyword">interface</span> J { J clone(); }
<span class="d_keyword">class</span> C : I
{
    <span class="d_keyword">override</span> C clone()   <span class="d_comment">// covariant overriding of I.clone()
</span>    {
        <span class="d_keyword">return</span> <span class="d_keyword">new</span> C;
    }
}

<span class="d_comment">// C.clone() can override I.clone(), indeed.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isCovariantWith</span>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(I.clone)));

<span class="d_comment">// C.clone() can't override J.clone(); the return type C is not implicitly
</span><span class="d_comment">// convertible to J.
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isCovariantWith</span>!(<span class="d_keyword">typeof</span>(C.clone), <span class="d_keyword">typeof</span>(J.clone)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".rvalueOf"></a><div class="quickindex" id="quickindex.rvalueOf"></div>@property T <a name="rvalueOf"></a><span class="ddoc_psymbol">rvalueOf</span>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);
<br><a name=".lvalueOf"></a><div class="quickindex" id="quickindex.lvalueOf"></div>@property ref T <a name="lvalueOf"></a><span class="ddoc_psymbol">lvalueOf</span>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);
</dt>
<dd><div class="summary">Creates an lvalue or rvalue of type <span class="d_inlinecode donthyphenate notranslate">T</span> for <span class="d_inlinecode donthyphenate notranslate">typeof(...)</span> and
<span class="d_inlinecode donthyphenate notranslate">_traits(compiles, ...)</span> purposes. No actual value is returned.
</div>
<div class="val"><p class="keyval Section"><span class="key keySection">Note:</span>
Trying to use returned value will result in a
"Symbol Undefined" error at link time.

</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate"><span class="d_comment">// Note that `f` doesn't have to be implemented
</span><span class="d_comment">// as is isn't called.
</span><span class="d_keyword">int</span> f(<span class="d_keyword">int</span>);
<span class="d_keyword">bool</span> f(<span class="d_keyword">ref</span> <span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(f(<span class="d_psymbol">rvalueOf</span>!<span class="d_keyword">int</span>)) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(f(lvalueOf!<span class="d_keyword">int</span>)) == <span class="d_keyword">bool</span>));

<span class="d_keyword">int</span> i = <span class="d_psymbol">rvalueOf</span>!<span class="d_keyword">int</span>; <span class="d_comment">// error, no actual value is returned
</span></pre>
</div></div>

</dd>
<dt class="d_decl"><a name=".isBoolean"></a><div class="quickindex" id="quickindex.isBoolean"></div>template <a name="isBoolean"></a><span class="ddoc_psymbol">isBoolean</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in boolean type.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBoolean</span>!<span class="d_keyword">bool</span>);
<span class="d_keyword">enum</span> EB : <span class="d_keyword">bool</span> { a = <span class="d_keyword">true</span> }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isBoolean</span>!EB);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isBoolean</span>!(SubTypeOf!<span class="d_keyword">bool</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isIntegral"></a><div class="quickindex" id="quickindex.isIntegral"></div>template <a name="isIntegral"></a><span class="ddoc_psymbol">isIntegral</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in integral type. Types <span class="d_inlinecode donthyphenate notranslate">bool</span>,
 <span class="d_inlinecode donthyphenate notranslate">char</span>, <span class="d_inlinecode donthyphenate notranslate">wchar</span>, and <span class="d_inlinecode donthyphenate notranslate">dchar</span> are not considered integral.</div>

</dd>
<dt class="d_decl"><a name=".isFloatingPoint"></a><div class="quickindex" id="quickindex.isFloatingPoint"></div>template <a name="isFloatingPoint"></a><span class="ddoc_psymbol">isFloatingPoint</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in floating point type.</div>

</dd>
<dt class="d_decl"><a name=".isNumeric"></a><div class="quickindex" id="quickindex.isNumeric"></div>template <a name="isNumeric"></a><span class="ddoc_psymbol">isNumeric</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in numeric type (integral or floating
point).</div>

</dd>
<dt class="d_decl"><a name=".isScalarType"></a><div class="quickindex" id="quickindex.isScalarType"></div>template <a name="isScalarType"></a><span class="ddoc_psymbol">isScalarType</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a scalar type (a built-in numeric, character or boolean type).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isScalarType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">float</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">bool</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isScalarType</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">dchar</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isBasicType"></a><div class="quickindex" id="quickindex.isBasicType"></div>template <a name="isBasicType"></a><span class="ddoc_psymbol">isBasicType</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a basic type (scalar type or void).</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!<span class="d_keyword">void</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">float</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">bool</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isBasicType</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">dchar</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isUnsigned"></a><div class="quickindex" id="quickindex.isUnsigned"></div>template <a name="isUnsigned"></a><span class="ddoc_psymbol">isUnsigned</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in unsigned numeric type.</div>

</dd>
<dt class="d_decl"><a name=".isSigned"></a><div class="quickindex" id="quickindex.isSigned"></div>template <a name="isSigned"></a><span class="ddoc_psymbol">isSigned</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a built-in signed numeric type.</div>

</dd>
<dt class="d_decl"><a name=".isSomeChar"></a><div class="quickindex" id="quickindex.isSomeChar"></div>template <a name="isSomeChar"></a><span class="ddoc_psymbol">isSomeChar</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is one of the built-in character types.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!<span class="d_keyword">byte</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!wstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!dstring);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeChar</span>!(<span class="d_keyword">char</span>[4]));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSomeString"></a><div class="quickindex" id="quickindex.isSomeString"></div>template <a name="isSomeString"></a><span class="ddoc_psymbol">isSomeString</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is one of the built-in string types.
</div>
<div class="description">The built-in string types are <span class="d_inlinecode donthyphenate notranslate">Char[]</span>, where <span class="d_inlinecode donthyphenate notranslate">Char</span> is any of <span class="d_inlinecode donthyphenate notranslate">char</span>,
<span class="d_inlinecode donthyphenate notranslate">wchar</span> or <span class="d_inlinecode donthyphenate notranslate">dchar</span>, with or without qualifiers.
<p></p>

Static arrays of characters (like <span class="d_inlinecode donthyphenate notranslate">char[80]</span>) are not considered
built-in string types.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">byte</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">typeof</span>(<span class="d_keyword">null</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isSomeString</span>!(<span class="d_keyword">char</span>[4]));

<span class="d_keyword">enum</span> ES : string { a = <span class="d_string">"aaa"</span>, b = <span class="d_string">"bbb"</span> }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isSomeString</span>!ES);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isStaticArray"></a><div class="quickindex" id="quickindex.isStaticArray"></div>template <a name="isStaticArray"></a><span class="ddoc_psymbol">isStaticArray</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a static array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[4][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[<span class="d_keyword">char</span>]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[1][]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!(<span class="d_keyword">int</span>[<span class="d_keyword">int</span>]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isStaticArray</span>!<span class="d_keyword">int</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isDynamicArray"></a><div class="quickindex" id="quickindex.isDynamicArray"></div>template <a name="isDynamicArray"></a><span class="ddoc_psymbol">isDynamicArray</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a dynamic array.</div>

</dd>
<dt class="d_decl"><a name=".isArray"></a><div class="quickindex" id="quickindex.isArray"></div>template <a name="isArray"></a><span class="ddoc_psymbol">isArray</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is an array (static or dynamic; for associative
  arrays see <a href="#isAssociativeArray"><span class="d_inlinecode donthyphenate notranslate">isAssociativeArray</span></a>).</div>

</dd>
<dt class="d_decl"><a name=".isAssociativeArray"></a><div class="quickindex" id="quickindex.isAssociativeArray"></div>template <a name="isAssociativeArray"></a><span class="ddoc_psymbol">isAssociativeArray</span>(T)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is an associative array type</div>

</dd>
<dt class="d_decl"><a name=".isBuiltinType"></a><div class="quickindex" id="quickindex.isBuiltinType"></div>template <a name="isBuiltinType"></a><span class="ddoc_psymbol">isBuiltinType</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a builtin type.</div>

</dd>
<dt class="d_decl"><a name=".isSIMDVector"></a><div class="quickindex" id="quickindex.isSIMDVector"></div>template <a name="isSIMDVector"></a><span class="ddoc_psymbol">isSIMDVector</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a SIMD vector type.</div>

</dd>
<dt class="d_decl"><a name=".isPointer"></a><div class="quickindex" id="quickindex.isPointer"></div>template <a name="isPointer"></a><span class="ddoc_psymbol">isPointer</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is a pointer.</div>

</dd>
<dt class="d_decl"><a name=".PointerTarget"></a><div class="quickindex" id="quickindex.PointerTarget"></div>template <a name="PointerTarget"></a><span class="ddoc_psymbol">PointerTarget</span>(T : T*)</dt>
<dd><div class="summary">Returns the target type of a pointer.</div>

</dd>
<dt class="d_decl"><a name=".pointerTarget"></a><div class="quickindex" id="quickindex.pointerTarget"></div>deprecated alias <a name="pointerTarget"></a><span class="ddoc_psymbol">pointerTarget</span> = PointerTarget(T : T*);
</dt>
<dd><div class="summary"><span class="red">Deprecated. Please use <a href="#PointerTarget"><span class="d_inlinecode donthyphenate notranslate">PointerTarget</span></a> instead. This will be
        removed in June 2015.</span></div>

</dd>
<dt class="d_decl"><a name=".isAggregateType"></a><div class="quickindex" id="quickindex.isAggregateType"></div>template <a name="isAggregateType"></a><span class="ddoc_psymbol">isAggregateType</span>(T)</dt>
<dd><div class="summary">Detect whether type <span class="d_inlinecode donthyphenate notranslate">T</span> is an aggregate type.</div>

</dd>
<dt class="d_decl"><a name=".isIterable"></a><div class="quickindex" id="quickindex.isIterable"></div>template <a name="isIterable"></a><span class="ddoc_psymbol">isIterable</span>(T)</dt>
<dd><div class="summary">Returns <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span> if T can be iterated over using a <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop with
 a single loop variable of automatically inferred type, regardless of how
 the <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop is implemented.  This includes ranges, structs/classes
 that define <span class="d_inlinecode donthyphenate notranslate">opApply</span> with a single loop variable, and builtin dynamic,
 static and associative arrays.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> OpApply
{
    <span class="d_keyword">int</span> opApply(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">ref</span> <span class="d_keyword">uint</span>) dg) { <span class="d_keyword">assert</span>(0); }
}

<span class="d_keyword">struct</span> Range
{
    @property <span class="d_keyword">uint</span> front() { <span class="d_keyword">assert</span>(0); }
    <span class="d_keyword">void</span> popFront() { <span class="d_keyword">assert</span>(0); }
    <span class="d_keyword">enum</span> <span class="d_keyword">bool</span> empty = <span class="d_keyword">false</span>;
}

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!(<span class="d_keyword">uint</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!OpApply);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!(<span class="d_keyword">uint</span>[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isIterable</span>!Range);

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isIterable</span>!<span class="d_keyword">uint</span>);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isMutable"></a><div class="quickindex" id="quickindex.isMutable"></div>template <a name="isMutable"></a><span class="ddoc_psymbol">isMutable</span>(T)</dt>
<dd><div class="summary">Returns <b>true</b> if T is not const or immutable.  Note that <a name="isMutable"></a><span class="ddoc_psymbol">isMutable</span> is <b>true</b> for
 string, or immutable(char)[], because the 'head' is mutable.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">inout</span> <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">inout</span> <span class="d_keyword">int</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isMutable</span>!(<span class="d_keyword">immutable</span> string));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isInstanceOf"></a><div class="quickindex" id="quickindex.isInstanceOf"></div>template <a name="isInstanceOf"></a><span class="ddoc_psymbol">isInstanceOf</span>(alias S, T)</dt>
<dd><div class="summary">Returns <b>true</b> if T is an instance of the template S.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Foo(T...) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Bar(T...) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> Doo(T) { }
<span class="d_keyword">static</span> <span class="d_keyword">struct</span> ABC(<span class="d_keyword">int</span> x) { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(Foo, Foo!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isInstanceOf</span>!(Foo, Bar!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isInstanceOf</span>!(Foo, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(Doo, Doo!<span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isInstanceOf</span>!(ABC, ABC!1));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(compiles, <span class="d_psymbol">isInstanceOf</span>!(Foo, Foo)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isExpressionTuple"></a><div class="quickindex" id="quickindex.isExpressionTuple"></div>template <a name="isExpressionTuple"></a><span class="ddoc_psymbol">isExpressionTuple</span>(T...)</dt>
<dd><div class="summary">Check whether the tuple T is an expression tuple.
 An expression tuple only contains expressions.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#isTypeTuple"><span class="d_inlinecode donthyphenate notranslate">isTypeTuple</span></a>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isExpressionTuple</span>!(1, 2.0, <span class="d_string">"a"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isExpressionTuple</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isExpressionTuple</span>!(<span class="d_keyword">int</span>, 2.0, <span class="d_string">"a"</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isTypeTuple"></a><div class="quickindex" id="quickindex.isTypeTuple"></div>template <a name="isTypeTuple"></a><span class="ddoc_psymbol">isTypeTuple</span>(T...)</dt>
<dd><div class="summary">Check whether the tuple <span class="d_inlinecode donthyphenate notranslate">T</span> is a type tuple.
 A type tuple only contains types.
</div>
<div class="keyval SeeAlso"><span class="key keySeeAlso">See Also:</span> <div class="val valSeeAlso"><a href="#isExpressionTuple"><span class="d_inlinecode donthyphenate notranslate">isExpressionTuple</span></a>.</div></div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isTypeTuple</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">float</span>, string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isTypeTuple</span>!(1, 2.0, <span class="d_string">"a"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isTypeTuple</span>!(1, <span class="d_keyword">double</span>, string));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isFunctionPointer"></a><div class="quickindex" id="quickindex.isFunctionPointer"></div>template <a name="isFunctionPointer"></a><span class="ddoc_psymbol">isFunctionPointer</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a function pointer.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">void</span> foo() {}
<span class="d_keyword">void</span> bar() {}

<span class="d_keyword">auto</span> fpfoo = &amp;foo;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!fpfoo);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!(<span class="d_keyword">void</span> <span class="d_keyword">function</span>()));

<span class="d_keyword">auto</span> dgbar = &amp;bar;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!dgbar);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!(<span class="d_keyword">void</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!foo);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFunctionPointer</span>!bar);

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFunctionPointer</span>!((<span class="d_keyword">int</span> a) {}));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isDelegate"></a><div class="quickindex" id="quickindex.isDelegate"></div>template <a name="isDelegate"></a><span class="ddoc_psymbol">isDelegate</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a delegate.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">void</span> sfunc() { }
<span class="d_keyword">int</span> x;
<span class="d_keyword">void</span> func() { x++; }

<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!dg);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()));
<span class="d_keyword">assert</span>(<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">typeof</span>(&amp;func)));

<span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!fp);
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">int</span> <span class="d_keyword">function</span>()));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isDelegate</span>!(<span class="d_keyword">typeof</span>(&amp;sfunc)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isSomeFunction"></a><div class="quickindex" id="quickindex.isSomeFunction"></div>template <a name="isSomeFunction"></a><span class="ddoc_psymbol">isSomeFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether symbol or type <span class="d_inlinecode donthyphenate notranslate">T</span> is a function, a function pointer or a delegate.</div>

</dd>
<dt class="d_decl"><a name=".isCallable"></a><div class="quickindex" id="quickindex.isCallable"></div>template <a name="isCallable"></a><span class="ddoc_psymbol">isCallable</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a callable object, which can be called with the
function call operator <span class="d_inlinecode donthyphenate notranslate">(...)</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">interface</span> I { <span class="d_keyword">real</span> value() @property; }
<span class="d_keyword">struct</span> S { <span class="d_keyword">static</span> <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">class</span> C { <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; } }
<span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!c);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!(c.opCall));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!(I.value));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isCallable</span>!((<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> a; }));

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isCallable</span>!I);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isAbstractFunction"></a><div class="quickindex" id="quickindex.isAbstractFunction"></div>template <a name="isAbstractFunction"></a><span class="ddoc_psymbol">isAbstractFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a an abstract function.</div>

</dd>
<dt class="d_decl"><a name=".isFinalFunction"></a><div class="quickindex" id="quickindex.isFinalFunction"></div>template <a name="isFinalFunction"></a><span class="ddoc_psymbol">isFinalFunction</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a a final function.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { <span class="d_keyword">void</span> bar() { } }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC { <span class="d_keyword">void</span> foo(); }
<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> bar() { }
    <span class="d_keyword">final</span> <span class="d_keyword">void</span> foo();
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalFunction</span>!(S.bar));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalFunction</span>!(FC.foo));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalFunction</span>!(C.bar));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalFunction</span>!(C.foo));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isNestedFunction"></a><div class="quickindex" id="quickindex.isNestedFunction"></div>template <a name="isNestedFunction"></a><span class="ddoc_psymbol">isNestedFunction</span>(alias f)</dt>
<dd><div class="summary">Determines whether function <span class="d_inlinecode donthyphenate notranslate">f</span> requires a context pointer.</div>

</dd>
<dt class="d_decl"><a name=".isAbstractClass"></a><div class="quickindex" id="quickindex.isAbstractClass"></div>template <a name="isAbstractClass"></a><span class="ddoc_psymbol">isAbstractClass</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a an abstract class.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">struct</span> S { }
<span class="d_keyword">class</span> C { }
<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> AC { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAbstractClass</span>!S);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isAbstractClass</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isAbstractClass</span>!AC);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".isFinalClass"></a><div class="quickindex" id="quickindex.isFinalClass"></div>template <a name="isFinalClass"></a><span class="ddoc_psymbol">isFinalClass</span>(T...) if (T.length == 1)</dt>
<dd><div class="summary">Detect whether <span class="d_inlinecode donthyphenate notranslate">T</span> is a a final class.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">class</span> C { }
<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> AC { }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC1 : C { }
<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC2 { }
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalClass</span>!C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_psymbol">isFinalClass</span>!AC);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalClass</span>!FC1);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( <span class="d_psymbol">isFinalClass</span>!FC2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Unqual"></a><div class="quickindex" id="quickindex.Unqual"></div>template <a name="Unqual"></a><span class="ddoc_psymbol">Unqual</span>(T)</dt>
<dd><div class="summary">Removes all qualifiers, if any, from type <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!<span class="d_keyword">int</span> == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">immutable</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">shared</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Unqual</span>!(<span class="d_keyword">shared</span>(<span class="d_keyword">const</span> <span class="d_keyword">int</span>)) == <span class="d_keyword">int</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ForeachType"></a><div class="quickindex" id="quickindex.ForeachType"></div>template <a name="ForeachType"></a><span class="ddoc_psymbol">ForeachType</span>(T)</dt>
<dd><div class="summary">Returns the inferred type of the loop variable when a variable of type T
is iterated over using a <span class="d_inlinecode donthyphenate notranslate">foreach</span> loop with a single loop variable and
automatically inferred return type.  Note that this may not be the same as
<span class="d_inlinecode donthyphenate notranslate">std.range.ElementType!Range</span> in the case of narrow strings, or if T
has both opApply and a range interface.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(<span class="d_keyword">uint</span>[]) == <span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!string == <span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(string[string]) == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ForeachType</span>!(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[]) == <span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".OriginalType"></a><div class="quickindex" id="quickindex.OriginalType"></div>template <a name="OriginalType"></a><span class="ddoc_psymbol">OriginalType</span>(T)</dt>
<dd><div class="summary">Strips off all <span class="d_inlinecode donthyphenate notranslate">enum</span>s from type <span class="d_inlinecode donthyphenate notranslate">T</span>.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">enum</span> E : <span class="d_keyword">real</span> { a }
<span class="d_keyword">enum</span> F : E    { a = E.a }
<span class="d_keyword">alias</span> G = <span class="d_keyword">const</span>(F);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!E == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!F == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">OriginalType</span>!G == <span class="d_keyword">const</span> <span class="d_keyword">real</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".KeyType"></a><div class="quickindex" id="quickindex.KeyType"></div>template <a name="KeyType"></a><span class="ddoc_psymbol">KeyType</span>(V : V[K], K)</dt>
<dd><div class="summary">Get the Key type of an Associative Array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">alias</span> Hash = <span class="d_keyword">int</span>[string];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">KeyType</span>!Hash == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(ValueType!Hash == <span class="d_keyword">int</span>));
<span class="d_psymbol">KeyType</span>!Hash str = <span class="d_string">"a"</span>; <span class="d_comment">// str is declared as string
</span>ValueType!Hash num = 1; <span class="d_comment">// num is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".ValueType"></a><div class="quickindex" id="quickindex.ValueType"></div>template <a name="ValueType"></a><span class="ddoc_psymbol">ValueType</span>(V : V[K], K)</dt>
<dd><div class="summary">Get the Value type of an Associative Array.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">import</span> std.traits;
<span class="d_keyword">alias</span> Hash = <span class="d_keyword">int</span>[string];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(KeyType!Hash == string));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">ValueType</span>!Hash == <span class="d_keyword">int</span>));
KeyType!Hash str = <span class="d_string">"a"</span>; <span class="d_comment">// str is declared as string
</span><span class="d_psymbol">ValueType</span>!Hash num = 1; <span class="d_comment">// num is declared as int
</span></pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Unsigned"></a><div class="quickindex" id="quickindex.Unsigned"></div>template <a name="Unsigned"></a><span class="ddoc_psymbol">Unsigned</span>(T)</dt>
<dd><div class="summary">Returns the corresponding unsigned type for T. T must be a numeric
 integral type, otherwise a compile-time error occurs.</div>

</dd>
<dt class="d_decl"><a name=".Largest"></a><div class="quickindex" id="quickindex.Largest"></div>template <a name="Largest"></a><span class="ddoc_psymbol">Largest</span>(T...) if (T.length &gt;= 1)</dt>
<dd><div class="summary">Returns the largest type, i.e. T such that T.sizeof is the largest.  If more
than one type is of the same size, the leftmost argument of these in will be
returned.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">ubyte</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">real</span>) == <span class="d_keyword">real</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">ulong</span>, <span class="d_keyword">double</span>) == <span class="d_keyword">ulong</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">double</span>, <span class="d_keyword">ulong</span>) == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Largest</span>!(<span class="d_keyword">uint</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>) == <span class="d_keyword">double</span>));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".Signed"></a><div class="quickindex" id="quickindex.Signed"></div>template <a name="Signed"></a><span class="ddoc_psymbol">Signed</span>(T)</dt>
<dd><div class="summary">Returns the corresponding signed type for T. T must be a numeric integral type,
otherwise a compile-time error occurs.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">alias</span> S1 = <span class="d_psymbol">Signed</span>!<span class="d_keyword">uint</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S1 == <span class="d_keyword">int</span>));
<span class="d_keyword">alias</span> S2 = <span class="d_psymbol">Signed</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S2 == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)));
<span class="d_keyword">alias</span> S3 = <span class="d_psymbol">Signed</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">uint</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(S3 == <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)));
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".mostNegative"></a><div class="quickindex" id="quickindex.mostNegative"></div>template <a name="mostNegative"></a><span class="ddoc_psymbol">mostNegative</span>(T) if (isNumeric!T || isSomeChar!T || isBoolean!T)</dt>
<dd><div class="summary">Returns the most negative value of the numeric type T.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">float</span> == -<span class="d_keyword">float</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">double</span> == -<span class="d_keyword">double</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">real</span> == -<span class="d_keyword">real</span>.max);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!<span class="d_keyword">bool</span> == <span class="d_keyword">false</span>);
</pre>
</div></div><div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_keyword">foreach</span>(T; TypeTuple!(<span class="d_keyword">bool</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>))
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!T == T.min);

<span class="d_keyword">foreach</span>(T; TypeTuple!(<span class="d_keyword">ubyte</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">ulong</span>, <span class="d_keyword">char</span>, <span class="d_keyword">wchar</span>, <span class="d_keyword">dchar</span>))
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">mostNegative</span>!T == 0);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".mangledName"></a><div class="quickindex" id="quickindex.mangledName"></div>template <a name="mangledName"></a><span class="ddoc_psymbol">mangledName</span>(sth...) if (sth.length == 1)</dt>
<dd><div class="summary">Returns the mangled name of symbol or type <span class="d_inlinecode donthyphenate notranslate">sth</span>.
</div>
<div class="description"><span class="d_inlinecode donthyphenate notranslate"><a name="mangledName"></a><span class="ddoc_psymbol">mangledName</span></span> is the same as builtin <span class="d_inlinecode donthyphenate notranslate">.mangleof</span> property, except that
the correct names of property functions are obtained.
<pre class="d_code notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.traits : <span class="d_psymbol">mangledName</span>;

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> value() @property;
}
<span class="d_keyword">pragma</span>(msg, C.value.mangleof);      <span class="d_comment">// prints "i"
</span><span class="d_keyword">pragma</span>(msg, <span class="d_psymbol">mangledName</span>!(C.value)); <span class="d_comment">// prints "_D4test1C5valueMFNdZi"
</span></pre>
</div>

</dd>
<dt class="d_decl"><a name=".Select"></a><div class="quickindex" id="quickindex.Select"></div>template <a name="Select"></a><span class="ddoc_psymbol">Select</span>(bool condition, T...) if (T.length == 2)</dt>
<dd><div class="summary">Aliases itself to <span class="d_inlinecode donthyphenate notranslate">T[0]</span> if the boolean <span class="d_inlinecode donthyphenate notranslate">condition</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>
and to <span class="d_inlinecode donthyphenate notranslate">T[1]</span> otherwise.</div>
<div class="keyval Examples"><span class="key keyExamples">Examples:</span> <div class="val valExamples"><pre class="d_code notranslate">
<span class="d_comment">// can select types
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Select</span>!(<span class="d_keyword">true</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">Select</span>!(<span class="d_keyword">false</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) == <span class="d_keyword">long</span>));

<span class="d_comment">// can select symbols
</span><span class="d_keyword">int</span> a = 1;
<span class="d_keyword">int</span> b = 2;
<span class="d_keyword">alias</span> selA = <span class="d_psymbol">Select</span>!(<span class="d_keyword">true</span>, a, b);
<span class="d_keyword">alias</span> selB = <span class="d_psymbol">Select</span>!(<span class="d_keyword">false</span>, a, b);
<span class="d_keyword">assert</span>(selA == 1);
<span class="d_keyword">assert</span>(selB == 2);
</pre>
</div></div>
</dd>
<dt class="d_decl"><a name=".select"></a><div class="quickindex" id="quickindex.select"></div>A <a name="select"></a><span class="ddoc_psymbol">select</span>(bool cond : true, A, B)(A <i>a</i>, lazy B <i>b</i>);
<br>B <a name="select"></a><span class="ddoc_psymbol">select</span>(bool cond : false, A, B)(lazy A <i>a</i>, B <i>b</i>);
</dt>
<dd><div class="summary">If <span class="d_inlinecode donthyphenate notranslate">cond</span> is <span class="d_inlinecode donthyphenate notranslate"><b>true</b></span>, returns <span class="d_inlinecode donthyphenate notranslate">a</span> without evaluating <span class="d_inlinecode donthyphenate notranslate">b</span>. Otherwise, returns <span class="d_inlinecode donthyphenate notranslate">b</span> without evaluating <span class="d_inlinecode donthyphenate notranslate">a</span>.</div>

</dd>
</dl>

</div>
<div id="copyright">Copyright Digital Mars 2005 - 2009.
 | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Fri May 29 11:56:59 2015
</div>

    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript">window.jQuery || document.write('<script src="../js/jquery-1.7.2.min.js">\x3C/script>')</script>
    <script type="text/javascript" src="../js/codemirror-compressed.js"></script>
    <script type="text/javascript" src="../js/run.js"></script>
    <script type="text/javascript" src="../js/cssmenu.js"></script>

<script type="text/javascript" src="../js/listanchors.js"></script>
<script type="text/javascript">jQuery(document).ready(listanchors);</script>
</body>
</html>
